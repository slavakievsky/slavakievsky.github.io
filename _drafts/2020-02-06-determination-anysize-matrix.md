---
layout: post
title: Зоопарк интерфейсов и TK, как выжить тулкит-наци?
description: plain
tags: [talks, maths]
---

Частенько в решении практических задач, так или иначе связанных с матрицами, возникает необходимость вычисления определителя. Ниже я предложу простой и занятный комбинаторный способ запрограммировать вычисление определителя любого (произвольного) порядка.
<!--more-->

## Математика определителя
Вспомним формулу определителя матрицы произвольного порядка:

{% include js-mathjax.js %}
$$
\text{detA} = \sum_{a_1, a_2,...a_n} (-1)^{\zeta(a_1,a_2,...a_n)}*a_{1_1}a_{2_2}...a_{n_n} \\ %*
$$

Где $\zeta$ -- некая мифическая "чётность перестановки".

Так как играть будем честно и по правилам я, пожалуй, введу определение "чётности перестановки". Введу самым, на мой взгляд, приятным и понятным способом -- через ладьи.

### Чётность перестановки: ладьи
Если посмотреть на формулу определителя произвольного, **n**-ного порядка, легко заметить, что она представляет собой полином первой степени, в каждом мономе которого находится ровно **n** различных элементов определителя.

Рассмотрим, к примеру, определитель четвёртого порядка:
$$
\begin{vmatrix}
    a_{11} & a_{12} & a_{13} & a_{14} \\
    a_{21} & a_{22} & a_{23} & a_{24} \\
    a_{31} & a_{32} & a_{33} & a_{34} \\
    a_{41} & a_{42} & a_{43} & a_{44}
\end{vmatrix}
= a_{11}a_{22} - a_{21}a_{12}
$$

Как его посчитать? казалось бы, что самый простой способ -- разложение по строке или столбцу. Подставлять в формулу как-то не очень хочется, да ещё и если учесть, что нам предстоит **запрограммировать** его вычисление...

А теперь, очень некстати на первый взгляд, отвлечёмся от линейной алгебры и вспомним про шахматы. Представим себе такую задачу:

**На шахматную доску 4х4 необходимо выставить как можно больше ладей, не бьющих друг друга. Показать все расстановки и доказать, что других нет.**

Решение на самом деле тривиальное, комбинаторное, и состоит из двух последовательных утверждений: 
1. В каждой строке (столбце) может быть не более одной ладьи
2. Существует 4! расстановок ладей, каждая из которых удовлетворяет условию задачи

> Интересный способ объяснения числа 4!, который нам пригодится в будущем: Выставим все ладьи на главной диагонали. Очевидно, что каждая строка и каждый стобец бьются ровно одной ладьёй, значит добавить нельзя ни одной ладьи. Следовательно любая другая расстановка ладей есть перестановка местами строк диагональной расстановки. Переставить местами 4 различных строки -- 4! различных способов по определению.

Теперь рассмотрим все подходящие по условию задачи расстановки ладей. Как было упомянуто выше, все они получаются путём перестановки местами строк (строки эквивалентны столбцам) "диагональной" расстановки (все ладьи стоят на всех клетках главной диагонали доски), которую мы в будущем будем называть **тривиальной расстановкой**. Для наглядности изображу эту расстановку в виде сетки:

$$
\begin{matrix}
    Л & - & - & - \\
    - & Л & - & - \\
    - & - & Л & - \\
    - & - & - & Л
\end{matrix}
$$

Примем "**знак**" тривиальной расстановки равным единице (1). Также введём операцию "**перестановки**", которая:
1. Выполнима при условии, что после выполнения п.2. получится ранее не встречавшаяся расстановка ладей
2. Меняет местами две строки
3. Умножает "знак" на (-1) и запоминает для полученной расстановки

Тогда, выполнив эту операцию 4! раз, мы получим 24 различные расстановки ладей на доске 4х4 таких, что никакие две ладьи не бьют друг друга. И каждой такой расстановке будет сопоставлен знак (1) или (-1)

Теперь представим, что мы нарисовали все эти расстановки на прозрачной плёнке, одну за другой. Под плёнку положим лист, на котором аккурат под сетками расстановок будут нарисованы абсолютно одинаковые матрицы 4х4, заполненные числами.

Для наглядности отображу пример наложения плёнки с расстановкой на матрицу:

$$
\begin{vmatrix}
    \pmb{A_{11}} & a_{12} & a_{13} & a_{14} \\
    a_{21} & \pmb{A_{22}} & a_{23} & a_{24} \\
    a_{31} & a_{32} & a_{33} & \pmb{A_{34}} \\
    a_{41} & a_{42} & \pmb{A_{43}} & a_{44}
\end{vmatrix}
$$

Жирным прописным шрифтом я выделил те места, в которых ладья "попадает" на число в матрице.

Легко заметить, что такая расстановка ладей отличается от тривиальной всего одной перестановкой строк с ладьями. Тогда, согласно определению операции перестановки, знак этой расстановки будет равен (-1).

Осталось только включить воображение, и представить, что мы имеем 24 таких картины, в каждой из которых мы, по сути, **выбираем 4 элемента матрицы, а среди полученных наборов никакие два не повторяются**. Перемножив элементы в каждом из этих наборов и просуммировав полученные мономы со знаками расстановок, им сопоставленных, мы и получим **определитель матрицы 4х4.** Выпишу его для вас в готовом виде :)

$$
\sum_{a_1, a_2,...a_n} (-1)^{\zeta(a_1,a_2,...a_n)}*a_{1_1}a_{2_2}...a_{n_n} \\ %*
$$

Теперь, надеюсь, стало прозрачно и понятно, что такое чётность перестановки в формуле определителя. Это чётность количества операций перестановок ладей (ладья символизирует место, на котором мы выбираем элемент матрицы), которые мы совершаем, получая очередной набор элементов матрицы.

Что же, поразвлекаться с ладьями предлагаю вам на досуге, а мы переходим к самому садкому...

## Программирование определителя
После истории с расстановками ладей становится совершенно очевидно, что запрограммировать вычисление определителя можно с помощью цикла, совершающего перестановки условных воображаемых ладей и суммирования ряда.

Условимся:
* Число **M** -- порядок вычисляемого определителя;
* Индексация массивов начинается с нуля и вообще _мы пишем на Питоне._

Нам потребуется, по сути, перебрать все возможные различные перестановки элементов массива [0...**M**]. Очень удобно, что индекс элемента этого массива можно принять номером строки числа в матрице, а значение -- номером столбца. Таким образом массив [0...**M**] является тривиальным и эквивалентен выбору элементов главной диагонали матрицы, а все возможные комбинации его элементов суть все возможные расстановки. Важно только правильно следить за знаком -- и дело в шляпе.

Для перебора всех возможных комбинаций напишем итерируемый генератор, но вы можете просто использовать _itertools.permutations_ для генерации всех перестановок. Метод _permutations_ генерирует перестановки в правильном с точки зрения чётности порядке.

Код генератора:
```python
def muta_gen(array: list):  # генератор будет рекурсивным
    if len(array) <= 1:  # если мы достигли конца массива,
        yield array  # то принятый массив вернем итератору
        return  # и заканчиваем поход во славу Адуна
    # если же мы еще работаем (функция не завершиласт)
    for mut in muta_gen(array[1:]):  #  дальше будем рекурсивно работать с перестановками
        for i,_ in enumerate(array):  # и вернем номер расстановки и саму расстановку
            yield mut[:i] + array[0:1] + mut[i:]
```

Такой алгоритм перебирает расстановки в необходимом порядке и мы можем итерироваться по объекту. Остаётся только лишь следить за знаком расстановки ладей.

Дальше дело обстоит достаточно просто: итерируемся по перестановкам и добавляем к общему определителю произведение элементов на местах, определяемых как индекс-число в нашей матрице с учетом знака:

```python
def det(A: np.array) -> int:
    det = 0  # Полный определитель
    sgn = 1  # Знак четности перестановки
    # Базовой эквивалентной расстановкой примем диагональную
    # Произведем перебор индексов перестановок
    shape = A.shape[0]
    idxs = muta_gen([i for i in range(shape)])  # генерируем расстановки в правильном порядке
    for mutid in idxs:
        mult = sgn
        for m in range(shape):
            mult *= A[m][mutid[m]]  # вот наше произведенице...
        det += mult  # которое мы прибавляем с учетом знака к определителю
        sgn *= -1
    return det
```

Осталось только проверить резальтат :)
```bash
py
```

*[полином]: многочлен :)
*[моном]: одночлен :)