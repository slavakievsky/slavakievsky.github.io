---
layout: post
title: Методичка линуксоида. Ликбез по GNU/Linux. Часть 2
description: Методичка начинающего линуксоида. Часть о файлах в системах GNU/Linux. Сжато и кратко, и, надеюсь, ёмко.
tags: [linux, guide]
---

Вот и вторая часть методички начинающего линуксоида. Это часть открывает, самый, на мой взгляд, сложный для написания и восприятия "блок начинающего сисадмина" нашей "методички". В этот раз рассмотрим файлы и всё, что сними связано в мире _<u>десктопного</u>_ Linux.

Погнали!

<!--more-->

><a href="/blog/linux-literacy">Часть первая, вводная</a>\\
><a href="/blog/linux-literacy-p3">Часть третья, про загрузку ОС</a>

## Файловая структура

Любая (в разумных пределах) десктопная система GNU/Linux представляет собой набор файлов и не более того. То немногое, что связывает вам руки при переносе системы копированием -- это загрузчик и, возможно, драйверы (вернее их отсутствие). Одной из основопологающих идей UNIX, а стало быть и Linux является догма "всё есть файл". Под словом "всё" действительно понимается всё. Жёсткий диск, сетевое устройство, ядро, ссылка на другой файл...

Отсюда следует, что любой объект файловой иерархии системы может быть
1. Прочитан
2. Записан, дозаписан (**>** и **\>\>** в shell или программа **tee**).
Нужно отметить, что в силу некоторых соображений некоторые типы файлов (о чём речь пойдет далее) окажутся недоступны для привычных операций чтения/записи.

### Базовые команды при операциях с файлами
* **ls** -- просмотреть список файлов в текущем или заданном каталоге
* **cat** -- прочитать содержимое файла и вывести его в стандартный вывод
* **less** -- прочитать содержимой файла, вывести его в приятном прокручивающемся консольном виде :)
* **tee** -- прочитать поток стандартного ввода и перенаправить его в стандартный вывод или в файл

### Типы файлов

Вместе с единством, однако, имеют место быть и некоторые различия. В настоящее время различают несколько типов файлов:

#### Inode
**Inode** (Index node, индексный узел) -- низкоуровневый объект файловой системы, содержащий данные о данных, или, по-просту, **метаданные**. Большинство современных inode содержат следующую информацию:
* Длина файла (в байтах)
* Идентификатор устройства, содержащего файл
* Идентификаторы владельцев файла
* Права доступа к файлу
* Счётчик ссылок ( при создании нового файла он принимается равным единице)
* Указатель на физическое расположение файла в блоках данных
* Время последнего
    * Изменение самого inode
    * Изменения файла, на который указывает inode
    * Чтения файла, на который указывает inode

Каждая файловая система хранит собственную организацию inode, а стало быть и собственную систему их нумерации. Во избежание конфликта номеров индексных узлов при использовании нескольких файловых систем, в оперативной памяти организуется единая система нумерации inode.

При создании файлов, POSIX-совместимые файловые системы выделяют этим файлам inode. Важно помнить, что индескиные узлы не хранят имя файла, но только лишь метаданные.

Каждый раз, когда осуществляется системный вызов удаления файла, счётчик ссылок уменьшается на 1. При достижении нулевого значения inode освобождается, и файл считается удалённым из файловой системы.

Всё, что нам нужно уметь делать с inode -- знать об их существовании, чтобы не допускать ошибок при работе с жёсткими ссылками.

Посмотреть, какие inode назначены файлам можно командой **ls -i**

#### Простые файлы
Эти файлы содержат только лишь последовательности байтов. Их можно читать, в них можно писать. В выводе команды **ls -l** эти файлы помечаются значком "-" в начале информационной строки.

#### Символьные файлы
**Символьным файлом** называется любой специальный файл системы Linux, предназначенный для обращения к переферийным устройствам, и для небуферизованного обмена данными с этими устройствами (буфер чтения/записи не хранится в оперативной памяти)

#### Символические ссылки
**Символическая ссылка** -- файл, который хранит ссылку на другой файл системы, обращаясь по его имени. При работе с символическими ссылками важно, чтобы система поддерживала этот тип файла, так как технически эти ссылки не являются какими-либо указателями и только лишь содержат информацию о имени файла, на который ссылаются.

Символические ссылки поддерживаются системами GNU/Linux.

Когда мы пытаемся прочитать или записать информацию в файл символической ссылки, операции перенаправляются к файлу, путь которого указан в этой ссылке.

Про символические ссылки важно помнить, что
1. Содержат только **имя** файла, на который ссылаются, а не данные
2. Удаление символической ссылки не приводит к удалению файла
3. Символические ссылки могут ссылаться на файлы и каталоги в других файловых системах
4. Если файл или каталог, на который ссылается символическая ссылка отсутствует, ссылка не пропадает, а операции чтения/записи аварийно завершаются с кодом **2: "Нет такого файла или каталога"**
5. Могут иметь права доступа, отличные от оригинального файла

#### Жёсткие ссылки
В отличии от символической, **жёсткая ссылка** является более низкоуровневым объектом, ссылающимся на inode другого, существующего в системе файла. Каждая жёсткая ссылка -- это отдельный файл, но ему сопоставлен тот же inode, что и "файлу-оригиналу". Таким образом жёсткая ссылка приобретает все права и наследует данные оригинального файла.

По сути, жёсткая ссылка -- вовсе не ссылка, а дополнительное имя файла в файловой иерархии.

Помните про то, что каждый inode хранит счётчик ссылок? По-умолчанию он равен 1, но при каждом создании жёсткой ссылки этот счётчик увеличивается на 1. Так как данные и inode хранятся до тех пор, пока значение этого счётчика более 0, удаление файла-оригинала не приводит к удалению данных, и доступ к ним можно будет осуществлять через жёсткую ссылку.

Про жёсткие ссылки важно помнить следующее:
1. Удаление жёсткой ссылки **или** изначального файла не приводит к удалению данных
2. Невозможно создать жёстую ссылку на каталог
3. Жёсткую ссылку почти невозможно отличить от обычного файла, так как она не имеет собственного inode и каких-либо отличительных аттрибутов, представляя собой, по сути, альтернативное имя файла
4. Жёсткие ссылки возможно создавать только внутри одной файловой системы (подумайте, почему).

#### Именованные каналы
Известные так же, как **именованные конвейеры** -- файлы, осуществляющие один из видов взаимодействия между различными процессами в операционной системе. Создать именованный канал можно командой  **mkfifo**, после чего можно записывать в него данные одним процессом и читать другим.

Этот тип файлов крайне редок в системе, так что вы вряд ли встретите их в реальной жизни, если не занимаетесь программированием под Linux.

Самый банальный пример использования **именованных пайпов** -- сжатие данных:
```bash
mkfifo namedpipe0
gzip -c < namedpipe0 > archived.gz
```
Это запустит процесс архиватора **gzip**, который будет сжимать все, что попадает в файл _namedpipe0_ и отправлять стандартным выводом в файл _archived.gz_

#### Сокеты
**Сокеты UNIX** так же представляют собой инструмент межпроцессного взаимодействия в операционных системах UNIX, Linux. Чаще всего сокеты используются в программах, имеющих архитектуру, в которой клиент обращается к серверу.

Можно сказать, что сокет -- это конечная точка обмена данными между процессами. Часто сокеты используются в сетевых клиент-серверных системах. Например протоколы POP3,SMTP используют именно сокеты для установки соединения и обмена данными.

В повседневной практике пользователи Linux могут столкнуться с понятием Socket-активации сервиса в SystemD. Смысл этого понятия в том, что вместо того, чтобы запускать сервис, systemd будет прослушивать соответствующий ему _.socket_ файл, а когда в него что-то попадёт, будет запущен необходимый процесс и информация будет передана ему для обработки.

#### Файлы блочного доступа (блочных устройств)
Это вид файлов в UNIX и Linux системах, обеспечивающих доступ к физическому или виртуальному устройству в виде простого файла в файловой системе. Типичными примерами файлов блочных устройств являются **/dev/sda**, **/dev/shm** и другие.

Блочным устройство называется потому, что обмен информацией с ним через файл происходит блоками данных. При чтении или записи данных в блочное устройство информация сохраняется в буфере системы.

Как правило, доступ к блочному устройству через соответствующий файл возможен в произвольном месте блочной структуры устройства, то есть можно указать, из какого именно места должен быть прочитан или записан блок данных.

Блочные файлы могут быть созданы автоматически при подключении физического или виртуального устройства к системе или быть заранее созданы и ассоциированы устройству при его подключении.

Что важно помнить про блочные устройства:
* Следует очень аккуратно относиться к записи в эти файлы! Всё, записываемое в них, пишется в устройство непосредственно на низком уровне!
* Любой файл в каталоге **/dev/** (о нём позже) является блочным устройством
* Доступ к жёстким дискам и флешкам осуществляется через блочные устройства
* В отличии от Windows в системах GNU/Linux отсутствует понятие "Диск C/D/E...". Блочные устройства предоставляют полноценный доступ к файловым системам на жестком диске.

### Файловые системы
В предыдущих пунктах мы часто оперировали понятием "**файловой системы**".

**Файловая система** -- это способ и порядок доступа и организации данных на физическом носителе в виде файлов.

Файловая система определяет
* На физическом уровне диска
    1. Расположение данных и метаданных (данных о данных)
    2. Формат хранения данных и метаданных
    3. Обработку случаев нехватки места для последовательной записи и т.п
* На логическом уровне
    1. Размер имени файла, систему его кодировки и допустимый набор символов
    2. Максимально возможный размер файла, раздела
    3. Набор аттрибутов файла (права доступа, свойства, расширенные аттрибуты)

Когда программа обращается к файловой системе, она не имеет никакого представления о том, как физически расположен файл на носителе информации, а так же на каком именно носителе он находится (а может и на нескольких). Файловая система самостоятельно определяет способ организации данных.

>Нужно отметить, что с развитием дисков SSD файловые системы всё меньше способны повлиять на физическое расположение блоков данных на носителе: контроллеры твердотельных дисков не предоставляют прозрачного доступа к низкому уровню организации данных, предпочитая самостоятельно заниматься организацией кластеров данных. Это способствует более равномерному износу ячеек SSD, а так же позволяет, в теории, использовать на таких дисках файловые системы, не предназначенные для SSD. Также стоит отметить возрастающую популярность шифрования данных на диске усилиями контроллера накопителя.

Частым явлением в файловых системах является **журналирование** данных и/или метаданных. Это означает, что файловая система ведёт журнал операций, который, при сбое процесса записи, позволяет определить, какие данные повреждены. Также иногда журнал позволяет без потерь восстанавливать повреждённые данные и/или метаданные.

В настоящее время существует несколько популярных на десктопных линуксах файловых систем:
1. EXT4 -- журналируемая файловая система. Отличается низкой степенью фрагментации данных, однако имеются сведения о слабо обратимой фрагментации метаданных. Надёжна, проверена временем и очень широко применяется.
2. XFS -- условно журналируемая файловая система. Показывает высокую производительность при работе с большими файлами на дисках большого объема (более 2 ТБ). По-умолчанию система журналирует только метаданные. Из-за отложенной записи на диск приобретает меньшую степень фрагментации и большую скорость, однако повышается и риск потери данных при сбое питания.
3. BTFS -- условно журналируемая файловая система, основанная на B-деревьях и технологии "копирования при записи". Поддерживает прозрачное сжатие данных "на лету", организацию RAID-массивов средствами самой файловой системы. Благодаря системе "копирования при записи" мгновенно создаются снэпшоты (копии, снимки состояния) данных и возможна их дедупликация. Целостность файлов обеспечивается проверкой контрольных сумм, а в случае их несовпадения, благодаря копированию при записи, файл откатывается к последнему целому состоянию.

#### Linux VFS
С точки зрения операционной системы, весь диск представляет собой набор кластеров. Драйверы файловой системы, не являющиеся независимыми от ядра и работающие в его пространстве, организуют кластеры в файлы и каталоги (которые, как мы помним, тоже являются файлами, содержащими список файлов). 

Благодаря подсистеме **VFS** (**V**irtual **F**ile **S**ystem) в Linux обеспечивается уровень абстракции над реализациями конкретных файловых систем, предоставляющий единообразный доступ к файлам для клиентских приложений. Иными словами любая программа использует возможности VFS для доступа к файлам внутри любой файловой системы, не заботясь об их физической организации и обращении к соответствующему драйверу.

Еще одной приятной особенностью VFS является то, что она декларирует программный интерфейс между ядром и конкретной файловой системой. Таким образом для добавления поддержки новой файловой системы в ядро не требуется вносить изменений в его исходные коды. 

### FHS
**FHS** (**F**ilesystem **H**ierarchy **S**tandard) -- стандарт, унифицирующий местонахождение файлов и каталогов с общего назначения в файловой системе UNIX (а стало быть и GNU/Linux).

FHS поддерживается и разрабатывается такими крупными игроками на рынке ИТ, как **HP, Red Hat, IBM** и **Dell**.

Однако важно помнить, что
* основная часть разработчиков дистрибутивов, включая даже и тех, кто входит в состав Free Standards Group, не следуют этому стандарту полностью.
* Некоторые Linux-системы полностью отвергают FHS и следуют своему собственному стандарту (таких, благо, меньшинство).

<div class="license-warn"> Далее находится слегка корректированный заимствованный текст. Я обязан указать, что он распространяется под лицензией CC BY-SA. Если Ваши религиозные взгляды не совместимы с данной лицензией -- ни в коем случае не читайте текст! ;)</div>

Ниже приведу таблицу, любезно [предоставленную](https://ru.wikipedia.org/wiki/FHS)
, Википедией:

|Каталог  |   Описание
|/ | Корневой каталог, содержащий всю файловую иерархию.
|    /bin | Основные утилиты, необходимые как в однопользовательском режиме, так и при обычной работе всем пользователям. Всё чаще является лишь ссылкой на /usr/bin
|    /boot | Загрузочные файлы (в том числе файлы загрузчика, ядро, initrd, System.map). Часто выносится на отдельный раздел.
 |   /dev | Основные файлы устройств (например, /dev/null, /dev/zero).
 |   /etc | Общесистемные конфигурационные файлы (имя происходит от лат. et cetera).
 |       /etc/opt | Файлы конфигурации для /opt.
 |       /etc/X11 | Файлы конфигурации X Window System версии 11.
|        /etc/sgml | Конфигурационные файлы SGML.
|        /etc/xml | Конфигурационные файлы XML.
|    /home | Содержит домашние каталоги пользователей, которые в свою очередь содержат персональные настройки и данные пользователя. Часто размещается на отдельном разделе.
|    /lib | Основные библиотеки, необходимые для работы программ из /bin и /sbin.
|    /media | Точки монтирования для сменных носителей, таких как CD-ROM, DVD-ROM.
|    /mnt | Содержит временно монтируемые файловые системы.
|    /opt | Дополнительное программное обеспечение.
|    /proc | Виртуальная файловая система, представляющая состояние ядра операционной системы и запущенных процессов в виде файлов.
|    /root | Домашний каталог пользователя root.
|    /run | Информация о системе с момента её загрузки, в том числе данные, необходимые для работы демонов. Часто сюда также монтируются флешки.
|    /sbin | Основные системные программы для администрирования и настройки системы. Часто -- сылка на /usr/sbin.
|    /srv | Данные для сервисов, предоставляемых системой (например, www или ftp).
|    /sys | Содержит информацию об устройствах, драйверах, а так же некоторых свойствах ядра.
|    /tmp | Временные файлы (см. также /var/tmp).
|    /usr | Вторичная иерархия для данных пользователя. Содержит большинство пользовательских приложений и утилит, используемых в многопользовательском режиме. Может быть смонтирована по сети только для чтения и быть общей для нескольких машин.
|        /usr/bin | Дополнительные программы для всех пользователей, не являющиеся необходимыми в однопользовательском режиме.
|        /usr/include | Стандартные заголовочные файлы.
|        /usr/lib | Библиотеки для программ, находящихся в /usr/bin и /usr/sbin.
|        /usr/local | Третичная иерархия для данных, специфичных для данного хоста. Обычно содержит такие подкаталоги, как bin, lib, share.
|        /usr/sbin | Дополнительные системные программы (такие как демоны различных сетевых сервисов), например, init, iptables, ifconfig
|        /usr/share | Архитектурно-независимые общие данные.
|        /usr/src | Исходные коды (например, здесь располагаются исходные коды ядра).
|    /var | Изменяемые файлы, такие как файлы регистрации, временные почтовые файлы, файлы спулеров.
|        /var/cache | Кэш приложений. Такие данные генерируются локально в результате ресурсозатратных вычислений или операций ввода-вывода. Приложение обязано уметь регенерировать эти данные, так что они могут быть удалены без потерь.
|        /var/lib | Информация о состоянии. Постоянные данные, изменяемые программами в процессе работы (например, базы данных, метаданные пакетного менеджера и др.).
|        /var/lock | Файлы блокировки, указывающие на занятость некоторого ресурса.
|        /var/log | Различные файлы регистрации.
|        /var/mail | Почтовые ящики пользователей.
|        /var/run | Каталог для хранения информации о системе с момента её загрузки, на данный момент устарел. Допускается делать его ссылкой на /run. Каталог оставлен для обратной совместимости с программами, которые всё ещё используют каталог /var/run.
|        /var/spool | Задачи, ожидающие обработки (например, очереди печати, непрочитанные или неотправленные письма).
|        /var/tmp | Временные файлы, которые должны быть сохранены между перезагрузками. 

## Credits
В следующих частях этого блока мы познакомимся с
* Процессом загрузки системы GNU/Linux
* Разграничением доступа, пользователи и группы
* Драйверами
* Интернетом

Также нас ждет третий блок, посвящённый графическому интерфейсу.

За фрагменты базовых определений спасибо Вики.
<span class="post-date">_...надеюсь, что оригинальность текста достаточна, чтобы я мог публиковать его под MIT... ну кроме того кусочка с таблицей..._</span>
