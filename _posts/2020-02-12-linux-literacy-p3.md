---
layout: post
title: Методичка линуксоида. Ликбез по GNU/Linux. Часть 3
description: Методичка начинающего линуксоида. Часть о процессе загрузки Linux. Сжато и кратко, и, надеюсь, ёмко.
tags: [linux, guide]
---

Здесь мы попробуем разобраться, как происходит загрузка операционной системы от нажатия кнопки питания до появления приглашения ввода пароля. Казалось бы, что всё тривиально, но если задуматься на мгновение, станет очевидно, что за какие-то 15 секунд загрузки пролетают десятилетия развития компьютерной индустрии: от Базовой Системы Ввода-Вывода до прозрачности окон графического интерфейса.
<!--more-->

><a href="/blog/linux-literacy">Часть первая, вводная</a>\\
><a href="/blog/linux-literacy-p2">Часть вторая, про файлы</a>

### BIOS & EFI
**BIOS** (**B**asic **I**nput-**O**utput **S**ystem) -- набор микропрограмм, зашитых в аппаратный чип материнской платы, реализующих API для работы с аппаратурой компьютера и подключёнными к нему устройствами.

**EFI**(**E**xtensible **F**irmware **I**nterface) -- интерфейс между операционной системой и микропрограммами, управляющими низкоуровневыми функциями оборудования. Основное предназначение EFI в том, чтобы корректно инициализировать всё оборудование при включении системы, а затем передать управление некоторой программе, к примеру, загрузчику операционной системы. EFI предназначен для замены устаревшего BIOS.

Историю развития BIOS, становления EFI оставлю за кулисами методички линуксоида и постараюсь кратко описать суть того, что происходит при загрузке системы.

И старый добрый Legacy BIOS, и новый навороченный UEFI от синей корпорации добра Intel работают по схожей схеме, которую обобщенно можно описать так:
1. Инициализация и тестирование аппаратуры, установленной в ПК (**POST** -- **p**ower-**o**n **s**elf-**t**est)
2. Чтение и применение настроек из энергонезависимой памяти на материнской плате
3. Размещение в начальных секторах оперативной памяти микропрограмм прерываний
4. Поиск кода для загрузки
5. Передача управления загруженному коду.

Основное различие, о котором нужно помнить линуксоиду состоит в том, откуда прошивка получает код для загрузки и передачи управления (пункты 4 и 5).


#### BIOS
В BIOS размещение кода, которому прошивка передаст управление, возможно в одном-единственном месте -- **MBR** (**M**aster **B**oot **R**ecord -- главная загрузочная запись). MBR распогогается в первом секторе жёсткого диска и имеет всего 512 байт доступных для записи. По этой причине, как правило, в этот сектор размещают не сам загрузчик ОС, а небольшую программу, которая в последствии прочитает код основного загрузчика и передаст управление ему.

То есть схема зугрузки современной ОС в системе BIOS выглядит следующим образом:
1. Загружается BIOS
2. Небольшая программа в MBR получает управление...
3. ... и находит на диске и загружает основной BootLoader (загрузчик)

Как вы уже наверняка догадались, в системах BIOS возможно использовать только диски с разметкой MBR (или GPT в **режиме совместимости, и то не всегда**).

#### EFI
С EFI ситуация обстоит чуть более приятным образом. Эта система располагает большим спкетром возможностей и умеет читать файловую систему FAT32. Код программы, которой система передаст управление должен быть помещён в разделе на жёстком диске, отформатированном в FAT32. Такой раздел должен иметь метку **ESP**(**E**FI **S**ystem **P**artition, ef00). Как правило его помещают вторым, но это не имеет значения.

По-умолчанию EFI загружает программу, находящуюся по следующему адресу: _**(ESP)/EFI/BOOT/BOOTX64.EFI**_, но большинство современных прошивок предоставляют возможность выбора загружаемого файла.

Такой подход к поиску загрузчика позволяет размещать код программы целиком на разделе ESP, а так же хранить множество прогамм и загрузчиков на одном разделе с возможностью загрузить их по мере необходимости.

Также EFI предоставляет возможность хранить в энергонезависимой памяти так называемые **Boot Entry** -- команды для системы с указанием расположения .efi кода, который необходимо загрузить. Например, если в системе установлены Windows, Linux и Memtest86, то список Boot Entries может выглядеть так:
1. Default 
    * (ESP)/EFI/BOOT/BOOTX64.EFI
2. Windows Boot Manager (on HGST1793872)
    * (ESP)/EFI/Microsoft/bootx64.efi
3. Ubuntu Linux (on HGST1793872)
    * (ESP)/EFI/Grub/grubx64.efi
4. Memtest (on HGST1793872)
    * (ESP)/EFI/memtest86/memtest86.efi

Для систем, управляемых EFI, рекомендуется использовать диски с разметкой GPT, так как этот стандарт предоставляет больше возможностей. Однако системы EFI умеют читать и диски MBR.

### Таблица разделов
Чуть ранее я упоребил такие термины, как **MBR** и **GPT**. Самое врем разобраться, что это такое.

Итак, разделы. Жёсткий диск -- это не беспорядочное месиво данных, а структурированное хранилище. Макро структурной единицей хранения данных на жёстком диске является раздел.

Технически, в ОС GNU/Linux жёсткий диск можно не разбивать на разделы и использовать, как единое устройство, но делать этого мы, конечно же, не будем.

В настоящее время наибольшее количество сердец завоевали таблицы разделов MBR и GPT.

**MBR**(**M**aster **B**oot **R**ecord) -- данные, необходимые для последующей загрузки операционной системы, расположенные в первых секторах жёсткого диска. MBR содержит загрузочный сектор (исполняемый код для загрузки после BIOS), таблицу разделов и специальную сигнатуру(подпись), по которой можно определить тип таблицы разделов.

**GPT**(**G**UID **P**artition **T**able) -- стандарт размещения информации о разделах на жестком диске, являющийся частью спецификации EFI. GPT содержит так называемую "Protective MBR", которая позволяет загружать код из первого сектора жёсткого диска, содержащего эту таблицу разделов.

До настоящего времени я не встречал случая, когда было оправдано использование диска c таблицей разделов MBR в системах EFI или наоборот.

Важно помнить, что при установке ОС в систему с EFI на диск GPT, нужно убедиться в наличии раздела ESP, отформатированного в FAT32 и имеющего метку ESP.

> Поздравляю! Только что вы прочитали предложение с самым большим количеством терминов на этом сайте до настоящего времени.

Если же вы используете MBR, то также важно убедиться, что в загрузочном секторе находится необходимый код загрузчика.

### Первичный загрузчик
Вот об этом загрузчике сейчас и пойдёт речь.

Основная задача загрузчика -- передать управление какой-то другой программе, будь то ядро ОС, другой загрузчик или же какая-то утилита для тестирования или настройки ПК без операционной системы (например Memtest).

В настоящее время условно часто используются загрузчики:
* **GRUB** (**GR**and **U**nified **B**ootloader) -- EFI, BIOS. Чаще всего используется в GNU/Linux системах.
* **rEFInd** -- EFI
* **SysLinux** -- EFI, BIOS
* **LILO** (**LI**nux **LO**ader) -- BIOS

Большинство из известных миру загрузчиков, работающих в системах BIOS с дисками MBR имеют слишком большой размер, чтобы уместить свой код в главной загрузочной записи. Потому в неё помещается некая кодовая прослойка, "предзагрузчик", в котором содержится минимальная необходимая информация: модуль для чтения таблицы разделов; драйвер файловой системы, на которой расположен основной загрузчик; код, который передаст управление основному загрузчику.

В системах EFI, где программы загрузчиков хранятся на разделе жёсткого диска, ситуация обстоит чуть проще, так как загрузчики умещаются на этом разделе целиком.

> Это не общее правило, и данную информацию следует уточнить по каждому конкретному загрузчику. Раздел ESP также может содержать предзагрузчики, если такова архитектура основного загрузчика.

Соответственно, после того, как основной код загрузчика получает управление, он либо заргужает ядро Linux, либо ядро Windows, либо что-то ещё.

### Ядро и initramfs
Вот оно, наконец-то.

Ядро, как и загрузчик (в этом смысле они похожи) является программой, которая должна получить управление. Для того, чтобы операционная система загрузилась. Но для ядра Linux всё уже немного сложнее: одной только программы ядра недостаточно для загрузки ОС. Ядру необходим целый набор модулей и инструкций для того, чтобы найти все файлы системы, прочитать все необходимые коды и т.д. Поместить всё это на жесткий диск нельзя. Из этих соображений и появляется **initramfs**.

**Initramfs = initrd**(**Init**ial **R**am **D**isk = **Init**ial **Ram** **F**il**s**ystem) -- временная файловая система, используемая ядром при загрузке. Находится в оперативной памяти и призвана решить проблему "курицы и яйца": чтобы загрузить модуля ядра нужен драйвер файловой системы, в которой они находятся, но чтобы прочитать ФС, нужен модуль ядра. Initramfs должна уже быть размещена в оперативной памяти к моменту получения ядром управления, чтобы оно (ядро) могло получить все необходимые данные и загрузить в последствии уже настоящую ОС.

Задача по размещению initramfs полностью ложится на плечи загрузчика.

Далее, после загрузки ядра и подключения всех модулей из initramfs (initrd), ядро подключает все необходимые файловые системы и передаёт управление **init** процессу.

Важно заметить, что ядро Linux поддерживает загрузку напрямую, без загрузчика. Это называется _EFISTUB_. Также есть возможность упаковать ядро и initramfs в одно .efi приложение, которое может быть запущено без загрузчика, напрямую из EFI.

### init процесс
**Init** -- это первый процесс, запускаемый ядром при загрузке операционной системы. Init -- общее название процесса, который осуществит некоторые действия, у примеру, подключение (монтирование) всех остальных файловых систем, запуск системных служб и программ, передача управления другим процессам, отслеживание выполнения процессов и т.д.

Функционал init процесса определяется тем, какая именно программа является им в конкретном дистрибутиве Linux. Сегодня, невзирая на почти религиозную ненависть, большинство дистрибутивов используют SystemD.

Так как init -- первый процесс, запускаемый ядром, он имеет PID 1.

По-умолчанию ядро запускает в качестве init-процесса программу, расположенную по пути _/sbin/init_.


Осуществив все необходимые приготовления, init-процесс запускает другие программы, среди которых встречаются как исполняемые файлы, взаимодействующие с пользователем (комнадный интерпретатор, графический сеанс), так и демоны.

### Демоны
**Демон**(daemon) -- класс программ, запускаемых, как правило, во время загрузки системы и выполняющихся в фоновом режиме без взаимодействия с пользователем.

В техническом смысле демон -- это процесс, у котогоро нет управляющего терминала. То есть он вот просто так висит себе в системе и что-то делает.

Демоны, в большинстве своём, служат для исполнения каких-то задач системы. Типичные задачи демонов:
* Почтовые серверы
* Управление печатью
* Управление сетевыми подключениями
* Выполнения задач по расписанию
* Управление питанием

Init-процесс тоже, в общем случае, является демоном.

Общаться с демонами и влиять на их поведение можно с помощью файлов конфигурации либо же посредствам сокетов/пайпов (о них я рассказывал в предыдущей части).

## Credits
В следующих частях этого блока мы познакомимся с
* Разграничением доступа, пользователи и группы
* Драйверами
* Интернетом

Также нас ждет третий блок, посвящённый графическому интерфейсу.