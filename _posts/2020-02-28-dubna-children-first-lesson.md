---
layout: post
title: День 1. Разбор творческого задания, генерация и хранение паролей.
description: Задание состоит в том, чтобы генерировать пароли и проверять их надёжность. Сгенерировать много таких пар и сохранить в каком-то виде в таблицу.
tags: [dubna-2020-python]
---

Первый разбор "полётов" для группы машинного обучения факультатива университета Дубна.

**Задача:** Написать программу, генерирующую случайный но запоминаемый пароль. Программа должна уметь оценивать сложность пароля.

**Доп.задача:** Сгенерировать несколько пар логин-пароль и записать их в какую-нибудь таблицу.
<!--more-->

**И самое главное:**
Если вы не умеете чего-то из того, что увидите ниже -- это совершенно не повод отчаиваться! Целью данного задания не было кого-то отсеять, отчислить или что-то в этом роде. **НЕТ.** Главная цель любой проверки -- выяснить, на каком уровне вы находитесь, что нужно доработать и на каких моментах заострить внимание. А главная цель этого курса -- научить :)

## Перед нами -- задача
Рассмотрим классическую схему постановки и решения задачи:
1. Формулирование задачи
2. Формализация задачи
3. Выбор способа решения
4. Решение задачи
5. Оценка результата

Сформулируем нашу задачу более кратко: перед нами стоит задача
**генерации запоминающегося случайного пароля и оценки его сложности и сохранения пар логин-пароль**.

Далее я предлагаю формализовать задачу. Что значит формализовать? Это значит, что задачу нужно описать на каком-то формальном языке. Так как перед нами не стоит математическая задача, предлагаю использовать язык требований и содержательного словесного описания.

### Задача №1: генерация

#### Формализация задачи
Чего мы хотим от нашей программы? Представляем ли мы себе алгоритм её работы? Для того, чтобы избежать "каши" в голове, разобъём задача на более мелкие фрагменты:
1. Сгенерировать пароль
2. Проверить сложность

Хорошо бы, чтобы наша программа, в случае слишком низкой (легко подобрать) или слишком высокой (сложно запомнить) сложности пароля осуществляла генерацию повторно. Видите? Уже начинают вырисовываться алгоритмические связи будущей программы!

Но как оценить сложность пароля Зад?ача поистине творческая, поэтому я предложу несколько самых очевидных критериев:
1. **Длина**: длинный пароль сложнее и запомнить и взломать
2. **Количество заглавных букв**: пароль, где много заглавных и строчных букв вперемешку сложнее и запомнить и взломать
3. **Сколько раз буквы стоят вперемешку с цифрами**: чем чаще буквы и цифры чередуются, тем сложнее запомнить и подобрать пароль.

По сути алгоритм оценки пароля уже готов и выглядит следующим образом:
1. Проверить сумму баллов по критериям:
    1. Длина
    2. Количество заглавных букв
    3. Буквы вперемешку с цифрами
2. Если полученное число (сумма) не находится в промежутке от "слишком легко" до "слишком сложно" -- повторить генерацию пароля.

Теперь осталось лишь сгенерировать пароль. Предлагаю генерировать пароль случайной длины, состоящий из случайных символов. Существует множество способов генерации случайного символа, но я выберу самый простой: использую библиотеку _string_ Питона.

Также важно условиться, что пароль будет содержать только буквы латинского алфавита и цифры.

Итак, общий алгоритм решения задачи, по сути, готов:
1. Генерация пароля
    1. Выбрать случайную длину для пароля
    2. В цикле от 0 до выбранной длинны добавлять к паролю случайный символ (букву латинского алфавита или цифру)
2. Проверка пароля
    1. Просуммировать:
        * Длина пароля в символах
        * Количество заглавных букв
        * Количество пар "буква"-"цифра"
    2. Если сумма больше, чем длина пароля умноженная на 2, то
        * Вернуться к пункту 1

#### Выбор способа решения
Здесь я предлагаю, не мудрствуя лукаво, определиться с тем, какие инструменты будем использовать:
1. Язык Python
    * Для случайностей -- библиотека _random_
    * Для символов -- библиотека  _string_

Также определимся с тем, как будет решаться каждый из пунктов. Для этого удобно построить блок-схему... но делать этого я не буду. Код достаточно простой...

#### Больше кода богу кода! (официально -- решение задачи на ЭВМ)
Для начала подключим в программу на Python все необходимые библиотеки:
```python
import random
import string
```

После чего займемся генерацией паролей:
```python
passwd_len = random.randint(4,10)  # длина пароля -- случайная от 4 до 10
passwd = ""  # пароль пока пустой

# Теперь склеим две строки: string.ascii_letters и string.digits в третью:
symbols = string.ascii_letters + string.digits  # разрешённые символы: буквы и цифры

for i in range(passwd_len):  # начинаем генерировать пароль
    passwd += random.choice(string.ascii_letters+string.digits)  # выберем случайный символ и добавим к паролю
```

Вот и готов наш пароль. Теперь проверим его сложность:
```python
# Посмотрим, сколько в пароле получилось пар буква-цифра:
chardig = 0  # количество таких пар
for i in range(1, passwd_len):
    pair = passwd[i]+passwd[i-1]
    if not pair.isdigit and not pair.isascii:  # Если строка не состоит только из цифр и не состоит только из букв
        chardig += 1  # значит нашлась пара буква-цифра

if len(passwd) + passwd.count(string.ascii_uppercase) + chardig > passwd_len*2:
    ## Пароль не подошел.
```

Чтобы при неподходящем пароле снова запустить процесс генерации, оформим весь код в цикл **while**. Полный код программы:
```python
import random
import string

good_password = False
passwd = ""

while not good_password:
    passwd_len = random.randint(4, 10)
    symbols = string.ascii_letters + string.digits
    for i in range(passwd_len):
        passwd += random.choice(string.ascii_letters + string.digits)
    chardig = 0
    for i in range(1, passwd_len):
        pair = passwd[i] + passwd[i - 1]
        if not pair.isdigit and not pair.isascii:
            chardig += 1
    if len(passwd) + passwd.count(string.ascii_uppercase) + chardig <= passwd_len * 2:
        good_password = True
    else:
        print("Bad password", passwd)

print(passwd)
```

Обратите внимание на новую переменную **good_password**. Такая переменная называется **флаг**. Использование флага в программе позволяет задать сколько угодно условий для одного и того же действия (в нашем случае этот флаг обозначает, что пароль подошёл).

Также я вынес объявление переменной **passwd** в начало программы, так как она используется позже, после прекращения цикла для вывода на экран. Это хороший тон :)

**Важно отметить**, что приведенное выше решение -- плод полуночной фантазии сонного студента с чашкой растворимого кофе в руках. Именно такого решения, ровно как и использования именно таких приёмов никто от ребят не ждал. Все без исключения, кто пришел на занятие, в большей или меньшей степени справились и каждый проявил креативность.

### Задача №2: таблица пар логин-пароль
Это задание, в идеале, требовало знания библиотеки **pandas**. Нужно было создать датафрейм, сгенерировать пароли (логины генерируются точно так же) и записать эти данные туда:
```python
import random
import string
import pandas as pd


def generate():  # оформим наш ранее написанный генератор в функцию
    good_password = False
    passwd = ""
    while not good_password:
        passwd_len = random.randint(4, 10)
        symbols = string.ascii_letters + string.digits
        for i in range(passwd_len):
            passwd += random.choice(string.ascii_letters + string.digits)
        chardig = 0
        for i in range(1, passwd_len):
            pair = passwd[i] + passwd[i - 1]
            if not pair.isdigit and not pair.isascii:
                chardig += 1
        if len(passwd) + passwd.count(string.ascii_uppercase) + chardig <= passwd_len * 2:
            good_password = True
    return passwd  # функция возвращает сгенерированную строку


logins_passwords = pd.DataFrame()  # создадим таблицу для данных
logins_passwords['login'] = [generate() for i in range(10)]  # сделаем 10 логинов
logins_passwords['passwd'] = [generate() for i in range(10)]  # и к ним 10 паролей
```