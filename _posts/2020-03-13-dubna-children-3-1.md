---
layout: post
title: День 3. Базовый синтаксис в Python.
description: Расмотрим базовые синтаксические конструкции языка Python3. Переменные, ветвления, циклы.
tags: [dubna-2020-python]
---

В этот раз мы рассмотрим базовые конструкции языка Python и научимся работать с переменными, циклами и условиями: познакомимся с синтаксисом, правилами и соглашениями о написании кода. Познакомимся с понятием "магического метода" и напишем класс рациональных дробей.

<!--more-->

## Переменные: присваивания, вычисления
Мы хорошо помним, что в языке программирования Python все переменные величины (на самом деле они константы) имеют тип _reference type_: переменная содержит указатель на _коробку_ в _куче_ данных.

Теперь познакомимся с технической стороной использования переменных в Python. Для праивльной и грамотной работы с переменными нужно помнить, что
1. Переменная появляется в памяти в момент присваивания ей значения -- нет нужды заранее объявлять переменные;
1. Тип переменной определяется в момент присваивания ей значения -- нет нужды специально объявлять тип переменной;
1. Переменная не содержит значение -- внутри перменной хранится ссылка;

Принимая во внимание выше перечисленные особенности, можно избежать множества ошибок при работе с переменными в Питоне.

### Присваивание
Присваивание переменной некторого значения происходит с помощью оператора присваивания. В языке Python этот оператор имеет следующий синтаксис:

```python
получатель = источник
````

_Получатель_ принимает значение, хранящееся в _источнике_. Очень важно помнить, что в данном случае знак равенства **не означает** равенство. Это оператор, который присваивает _получателю_ значение из _источника_.

В языке Python также существуют конструкции, упрощающие запись некоторых случаев присваивания:
* _a = a + b_ эквивалентно _a += b_
* _a = a - b_ эквивалентно _a -= b_
* _a = a / b_ эквивалентно _a /= b_
* _a = a * b_ эквивалентно _a *= b_
* _a = b * b * b_ эквивалентно _a = b ** 3_

### Определение операций над данными
Для того, чтобы выполнить какую-то операцию (например сложение) интерпретатор  Python должн знать, что конкретно ему делать. Например, если для целых чисел не определена операций сложения, то мы не сможем вычислить значение выражения _2 + 3_. 

Любой тип данных в Python -- это класс, а любой представитель этого типа -- экземпляр класса. К примеру, число 15 -- экземпляр класса **int**.

Как вы помните, для класса объектов можно определять методы (то есть действия, которые можно производить с экхемплярами этого класса). Операции сложения, умножения и т.д. -- тоже действия над объектами, а следовательно они тоже должны быть определены, как методы класса.

В Python по-умолчанию определены операции для строк, чисел и логических значений (True/False), сипсков и кортежей. Очень важно помнить, что эти операции определены **по разному для разных классов**. Например для списков(массивов) определена операция сложения, результатом которой является новый массив, состоящий из элементов первого и второго массивов последовательно:
```python
>>> a = [1,2]
>>> b = [3,4]
>>> a + b
[1,2,3,4]
```
А вот операция вычитания для списков _не определена_, поэтому данный код завершится с ошибкой:
```python
>>> a = [1,2,3]
>>> b = [1]
>>> a - b
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for -: 'list' and 'list'
```
Видно, что интерпретатор сообщает нам: "я не знаю, как произвести вычитание массива из массива"

Также определены собственные операции для строк, чисел, логических значений.

#### Как определить операцию в собственном классе?
Если мы пишем собственный класс и хотим, чтобы можно было, к примеру, сложить два объекта этого класса оператором "+", необходимо определить метод сложения.

Методы операций сложения, вычитания и т.д. имеют конкретные имена. Как только внутри класса объявляется метод с одним из этих имён, операция считается определенной. Метод, который мы объявляем, чтобы сообщить интерпретатору, как производить над экземплярами класса определенные действия (не только математические операции, но и преобразование типов, вывод в консоль, присваивание значений и много чего еще) называются **магическим методом**.

**Магический метод** -- это особые методы класса в Python, которые не вызываются напрямую, а исполняются некоторыми операциями интерпретатора.

Например, магический метод **\_\_add\_\_(self, other)** будет вызван, если в коде программист напишет **self + other**. (не self и other, а имена двух объектов определенного класса). Иными словами код **a + b** на самом деле вызывает функцию **a.__add__(b)**.

К примеру, давайте напишем собственный класс Животное, для котогоро определим операцию сложения, в результате которой будет создано новое, третье, животное:
```python
class Animal:
    def __init__(self, name):
        self.name = name

    def __add__(self, other):
        return Animal(self.name+other.name)
```

Что здесь написано?
При создании нового животного мы даем ему имя. Если прибавить к одному животному другое -- получится третье животное, имя которого состоит из имен первого и второго (здесь мы, кстати, пользуемся тем, что операция сложения уже определена для строк).

Давайте проверим:
```python
>>> a1 = Animal('dog')
>>> a2 = Animal('cat')
>>> a3 = a2 + a1
>>> a3.name
'catdog'
```
С помошью функции **id()** легко убедиться, что **a1, a2, a3** содержат ссылки на _три разных_ объекта.

> Со стандартными операциями над массивами и числами предлагаю Вам ознакомиться самостоятельно.

## Условные операторы: ветвление
Часто бывает так, что дальнейший ход программы зависит от выполнения/невыполнения некоторых условий. Такое поведение называется **ветвлением**, а конструкция, которая осуществляет _ветвление_ называется **условным оператором**.

**Условный оператор** -- разновидность управляющей конструкции языка программирования, обеспечивающая выполнение определённого набора команд только при условии истинности некоторого логического выражения.

Любой _условный оператор_ состоит как минимум из двух частей:
1. Условие
1. Код, который выполнится, если условие верно (тело)


В Python условный оператор может состоять из следующих частей:
1. Условие
    * Код, который выполнится, если условие верно
1. Альтернативное условие
    * Код, который выполнится, если основное условие не верно, но верно альтернативное
1. Иначе
    * Код, который выполнится, если ни одно из условий не оакзалось верно

Из этих частей обязательной является только _первая_: основное условие и код, который выполнится при его истинности.

Альтернативных условий может быть очень много.

### Условие
Что же такое условие и что значит, что _условие верно_? В языке Python _условием_ должно являться логическое значение True/False либо же выражение, результатом которого будет такое значение.

Если значение _True_ -- условие считается выполненным. Если _False_ -- то нет.

Обратите внимание, что условием может являться и одна переменная и даже простое True: **if True:**.

Также важно помнить, что операции сравнения должны быть _определены_ для сравниваемых элементов (см ранее об операциях). Иначе код аварийно завершится с ошибкой.

Рассмотрим некоторые примеры:
```python
>>> a = 12
>>> b = "abc"
>>> if a == b:
...     print("Этот код никогда не выполнится")
>>> if a > b:
...     print("Этот код завершится с ошибкой! Операция сравнения строки и числа не определена")
```
Также, так как условие есть логическое значение, в качестве условия может выступать переменная, для которой определено преобразование в тип _bool_. Например bool("abc") -> True, а bool("") -> False. Так уж определено для строк.

Операции преобразования в какой-то тип данных тоже определяются с помощью магических методов класса.

### Тело
То, ради чего и существует условный оператор: действия, который программа будет выполнять в зависимости от выполнения условия.

В Python тело условного оператора, как и любой вложенный блок кода, отделяется отступом. Тело условного оператора закончится вместе с возвратом кода на тот же уровень отступа, на котором находится условие:
```python
a = True
if a:  # Условие -- логическая переменная. Почему нет?
    # Вот тело условного оператора
    print("a is True")
elif not a:  # Альтернативное условие №1 условие: операция "not a"
    # Тело альтернативного условия
    print("a is False")
    print("Это все еще тело")
    # Тело не кончится, пока отступ не вернется обратно
# Тело кончилось, но почему бы не добавить еще одно альтернативное условие?
elif not a and not not a: # Не а и не не а -- результат тоже логическое число
    print("Мир сломался!")
else:  # Если ни одно из условий не выполнено...
    print("Мир совсем сломался... :(")
    print("А вот блок кода еще не закончился")
    if "abc":  # логические значение непустой строки -- True
        print("Почему бы не сделать вложенный блок в блоке?")
print("А вот этот оператор не зависит от условий. Он вне тела условия")
```

## Циклы
Еще один метод управления процессом исполнения программы -- цикл.

Цикл используется, когда программисту необходимо выполнить некоторую последовательность операций несколько раз, полностью или с некоторыми изменениями повторяя совершаемые действия.

**Цикл** -- разновидность управляющей конструкции, предназначенная для многократного исполнения набора инструкций.

**Телом цикла** называется та самая последовательность, которая предназначена для многократного исполнения.

### Виды циклов в Python
В языке python существует два вида циклов: **итеративный** и **условный**.

**Итеративный** цикл -- цикл, который исполняет _тело_ некоторое количество раз. У такого цикла существует параметр, который по очереди принимает значения из некоторой последовательности. Цикл завершится, как только эта последовательность закончится.

**Условный** цикл -- цикл, который исполняет _тело_ до тех пор, пока верно условие его продолжения.

#### Итеративный цикл
Синтаксис итеративного цикла прост:
```python
for параметр in последовательность:
    тело
```
Параметру необходимо назначить имя (параметр -- переменная), например "i".
Последовательность не может быть чем угодно: это должно быть значение, принадлежащее одному из следующих типов:
1. List -- список, массив
2. Tuple -- кортеж (неизменяемый массив)
3. Set -- множество (изменяемый, но не упордоченный массив, все элементы в котором различны)
4. Итератор (с ними мы познакомимся сильно позже)

К примеру код
```python
for i in 4:
    print(i)
```
Завершится с ошибкой **'int' object is not iterable**. Это значит, что значение типа int (экземпляр класса int) не является последовательностью.

Пример использования цикла for:
```python
for i in range(10):
    print(i)
```
Функция **range()** позволяет превратить целое число в последовательность от 0 до этого числа. На самом деле у функции есть еще два необязательных параметра: в общем случае она выглядит так:

**range(m, n, k)** генерирует последовательность целых чисел от **m** до **n** с шагом **k**. Например:
```python
>>> p = "hello"
>>> for i in range(-2, 5, 3):
...     print(p, i)
hello -2
hello 1
hello 4
```
Как видите, переменные, объявленные вне цикла, можно использовать и изменять внутри этого цикла.

#### Цикл с условием выполнения (условный)
Цикл с условием похож на условный оператор _if_: в нем тоже есть условие. _Тело_ цикла будет выполняться до тех пор, пока условие цикла верно.

Синтаксис тоже достаточно прост:
```python
while условие:
    тело
```

Точно так же, как и в случае условного оператора, **условие** -- это некоторое логическое значение (True/False) либо выражение, результатом которого является логическое значение.

Пример цикла:
```python
>>> a = 12
>>> while a > 0:
...     print(a)
...     a -= 1
12
11
10
9
8
7
6
5
4
3
2
1
```

Как видите, переменные, объявленные вне цикла, можно использовать и изменять внутри этого цикла.

## Бонус: класс для рациональной дроби
Напишем собственный тип данных! Рациональная дробь.

**Рациональной дробью** называется число **m/n**, где **m** -- целое число, а **n** -- целое и больше нуля.

Время кодить! (привыкаем к документированию кода с помощью **"""**)
```python
class Rational:
    """
    Это -- класс рациональных дробей.

    Рациональная дробь -- дробь вида m/n, где m - целое, n - натуральное.
    Определим операции сложения, вычитания и умножения.

    Пока не будем производить проверку чисел m и n.
    Также условимся, что операции определены только для двух дробей,
        то есть мы не будем пытаться прибавить к дроби, например, число.
    """
    def __init__(self, m, n):
        """
        Это -- конструктор.

        Он автоматически вызывается при создании нового
            экземпляра класса Rational.

        Конструктор принимает два аргумента: m и n:
            m -- числитель дроби
            n -- знаменатель дроби
        """
        self.m = m
        self.n = n

    def __add__(self, other):
        """
        Это -- магический метод __add__.

        Он вызывается, когда мы пишем "a + b".
        То есть "a + b" -> "a.__add__(b)".

        Помним, что ключевое слово self обязательно должно стоять на первом месте,
            и его не надо передавать методу.

        self -- это наше число.
        other -- это число, которое мы прибавляем.

        Ранее мы условились, что к дроби будем прибавлять только дробь.

        Функция возвращает новую дробь (новый экземпляр класса Rational),
            числитель и знаменатель которой получены по правилам сложения
            дробей с приведением к общему знаменателю.
        """
        ob_n = self.n * other.n
        self_new_m *= other.n
        other_new_m *= self.n
        return Rational(self_new_m+other_new_m, ob_n)

    def __sub__(self, other):
        """
        Это -- магический метод __sub__.

        Он заменяет операцию вычитания: "a - b" -> "a.__sub__(b)".

        Точно так же: вычитаем из дроби тольк одробь (иначе будет ошибка),
            Возвращаем новый объект, числитель и знаменатель которого
            получены по правилам вычитания дробей.
        """
        ob_n = self.n * other.n
        self_new_m *= other.n
        other_new_m *= self.n
        return Rational(self_new_m-other_new_m, ob_n)

    def __mul__(self, other):
        """
        Это -- магический метод __mul__.

        Он осуществляет операцию умножения: "a * b" -> "a.__mul__(b)".

        Возвращает новую дробь.
        """
        return Rational(self.m*other.m, self.n*other.n)
```