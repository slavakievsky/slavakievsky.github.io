---
layout: post
title: Заметки по работе с Git. Часть 1.
description: Первая часть практических заметок и напоминалок по работе с GitHub(Lab). Создание и использование репозитория, коммиты, пуши.
tags: [git, guide]
---

Часто бывает так, что, казалось бы, элементарные и простые вещи вылетают из головы. Использование Git для версионирования проекта, контроля за изменениями кода (и не только кода) или размещения исходных кодов в удалённом репозитории -- один из тех базовых навыков, без которых современному программисту придётся очень тяжко.
Если ты, как и я, иногда забываешь, чо делать-то, чтобы залить программу в интернеты, эта серия заметок -- для тебя.

<!--more-->

## Часть практическая

Просто оставлю это здесь. Если интересует более подробное и литературное описания работы с Git, милости прошу вниз)

### Клонировать
Если хочешь получить локальную копию уже существующего репозитория:
```bash
git clone _адрес_репо_
```

### Сделать коммит
```bash
git add _имена_файлов_которые_надо_закоммитить_
git commit -m "Комментарий"
```

### Залить в интернеты
Запихать все сделанные коммиты в удалённый репозиторий (например на GitHub):
```bash
git push
```

### Много кода, но не догадался сразу сделать репозиторий
Только что создал репозиторий на GitHub(Lab), но уже есть локальные коммиты
```bash
git remote add origin _адрес_репо_
git push -u origin master
```

### А что там с изменениями?
```bash
git status
```

### Что именно я натворил?
```bash
git show
```
### Полный цикл -- от изменения до пуша
```bash
git clone https://github.com/pushsla/testrepo.git
cd testrepo
touch newFile.file
git add newFile.file
git commit -m "new file added"
git push
```
### Не хочу, чтобы git следил за файлом
Просто добавь имя файла в файл ".gitignore" в корне репозитория
```bash
cd testrepo
touch UntrackedFile.file
```
Отредактируй (создай) файл ".gitignore" и напиши с новой строчки "UntrackedFile.file". Готово! Теперь Git'у вообще будет наплевать на этот файл и он никогда не попадет в коммит, а следовательно -- и в удалённый репозиторий.


## Что такое Git
**Git** -- это распределенная система управления версиями. Версиями чего угодно. В программировании -- версиями исходных кодов программы. Иными словами, git -- это ПО, облегчающее процесс контроля изменений, позволяющее хранить сразу несколько версий какого-то документа в виде своеобразного "дерева" изменений.

Хочу отметить, что Git -- далеко не единственный представитель подобного класса систем, но в данной серии заметок я соберу информацию только о работе с Git.

Изначально git была придумана самим Linus Torvalds непосредственно для того, чтобы контролировать процесс разработки ядра Linux.

Существует так называемое "**ядро git**" -- набор утилит командной строки, позволяющих работать с системой git. Абсолютно все настройки системы хранятся в текстовых конфигах.

### GitHub
**GitHub** -- это веб-сервис, который предоставляет ресурсы для бесплатного (для проектов с открытым исходным кодом) хостинга различных проектов. Благодаря тому, что сервис основан на системе контроля версий Git, GitHub предоставляет классный и удобный сервис для совместной разработки ПО.

Помимо размещения исходного кода, его версионирования, контроля изменений и всего, что включает в себя система Git, GitHub также предоставляет разработчикам возможности для общения, отслеживания состояния различных проектов и т.д.

Также для тех, кто ~~ленив~~ не подружился с командной строкой есть веб-интерфейс, реализующий возможности системы Git. Но реальный пацаны сидят в терминале, конечно.

## Репозиторий

**Репозиторий Git** (Не обязательно GitHub) -- ни что иное, как каталог в файловой системе. В этом каталоге хранятся все конфигурационный файлы, необходимые ядру git для работы с репозиторием. Кроме того в этом каталоге находится так называемый **индекс**, который описывает расположение различных файлов для быстрого отслеживания изменений. Ну и, конечно, в репозитории хранятся собственно наши драгоценные данные.

Кроме того, git репозиторий содержит также _особое хранилище_ состояний файлов, которые фиксируются каждый раз при внесении в рабочий репозиторий изменений (коммите). Каждый раз, когда ядро git обрабатывает новые изменения, оно на самом деле создает копии изменений и помещает их в это особое хранилище. Этим гарантируется, что всегда возможно выполнить "откат" к предыдущим версиям репозитория вне зависимости от внесенных изменений. Единственное исключение -- если файл был удален из индекса репозитория.

Легко заметить, что абсолютно любое дерево каталогов в файловой системе можно превратить в Git репозиторий, следить за изменениями и даже синхронизировать между разными компьютерами посредством какого-нибудь веб-сервиса (на этот раз привет, GitHub).

### Создание нового локального репозитория

Чтобы создать новый репозиторий, необходимо перейти в каталог, который будет являться корнем репозитория (не обязательно пустой). После чего выполняется команда:
```bash
git init
```
Эта команда создаст все необходимые файлы и каталоги (по умолчанию -- каталог _.git_), проиндексирует все файлы и создаст пустое _особе хранилище_ версий.

Все файлы, которые были в корневом каталоге репозитория до "инициализации" считаются новыми в репозитории. То есть подлежат фиксированию (коммиту).

### Фиксирование изменений содержимого

Каждый раз, когда ты производишь какие-то изменения (удаление, создание нового файла, изменение существующего), реальное содержимое репозитория начинает отличаться от того, что находится в _особом хранилище_ состояния.

Разница между тем, что находится в _хранилище состояния_ и тем, что реально прямо сейчас находится в файловом дереве репозитория и есть **изменение**.

Если ты считаешь, что пройден некоторый осмысленный этап в разработке программного продукта -- значит настало время _зафиксировать_ накопившиеся в репозитории изменения. Для этого необходимо пройти два этапа:
1. Указание файлов, изменения которых нужно зафиксировать
2. Фиксирование изменений -- коммит

Первый этап -- обязателен. Очень удобно, что в один коммит можно включить не все изменения, а только те, которые нужно. Это позволяет контролировать историю изменений более гибко.

Перед тем, как фиксировать накопившиеся изменения, рекомендую посмотреть краткий их список, чтобы решить, какие файлы попадут в очередной коммит:
```bash
git status
```
В выводе этой команды ты увидишь, какие файлы бали удалены, какие созданы, а какие изменены.

Далее приступаем к фиксированию изменений:
```bash
git add _имя_файла_
```

Затем создаем коммит:
```bash
git commit -m "комментарий коммита"
```
Комментарий -- важная часть коммита. Грамотные и подробные комментарии того, что именно было изменено с момента последнего коммита, позволяют отслеживать развитие программы, быстро и безболезненно откатывая её до последнего рабочего состояния, если что-то идёт не так.

Собственно -- всё! Теперь в _особом хранилище_ создано новое состояние репозитория, которое совпадает с текущим его содержимым тех файлов, которые были включены в коммит командой "git add".

### Как "залить" изменения в удалённый репозиторий?

Но коммит -- это только половина счастья. Мы хотим пойти дальше, и разместить наш исходный код в удалённом репозитории. Например, на GitHub.

Для этого необходимо две вещи:
1. Локальный репозиторий, в котором есть зафиксированные изменения (коммиты)
2. Удалённый репозиторий, состояние которого совпадает с одним из предыдущих состояний локального репозитория

На втором пункте стоит остановиться чуть подробнее. Предположим, над проектом работают два человека: Никита и Слава. У каждого есть свой локальный репозиторий, а на GitHub размещен репозиторий удалённый. Изначально все три репозитория совпадают.

Но вот, Никита создает новый файл. Появляется изменение, которое Никита незамедлительно фиксирует коммитом:
```bash
touch newImportantFile.txt
git add newImportantFile.txt
git commit -m "Important commit!"
```

Но Слава также решает создать новый, не менее важный файл:
```bash
touch newImportantFile.txt
git add --all
git commit -m "Important file!"
```

Теперь, если сравнить удалённый репозиторий с репозиторием Никиты, окажется, что Никита "опережает" GitHub на один коммит. То есть удалённый репозиторий соответствует тому состоянию, которое было у репозитория Никиты ровно один коммит назад. Та же ситуация, если сравнить репозиторий на GitHub с тем, что есть у Славы.

Но вот настает пора Славе сделать "пуш" своего репозитория. То есть "залить" его на GitHub, если угодно.

Слава может "запушить" (push) в удалённый репозиторий только те изменения, которые были зафиксированы коммитом:
```bash
git push
```
Теперь содержимое репозитория на GitHub обновляется и становится идентичным тому, что находится на компьютере Славы.

Никита тоже решает запушить изменения на GitHub, но у него что-то не получается. Дело в том, что текущее состояния удалённого репозитория не соответствует ни одному из зафиксированных состояний Никитиного. Получается, что GitHub не отстаёт от Никиты, а значит не известно, как же обновить содержимое удалённого репозитория. О том, как разрешить этот конфликт, я обязательно упомяну в последующих частях. А Никита просто решил забить, и сказать Git'у, чтобы он игнорировал созданный им файл.

Для этого Никита создает в корне репозитория файл ".gitignore" и вписывает туда имя созданного им файла:
**.gitignore**
```
newImportantFile.txt
.gitignore
```

> Если Никита не запишет имя самого файла .gitignore в него же, то снова окажется, что состояние его репозитория не соответствует ни одному из состояний удалённого. Чтобы этого избежать, Никита решил, что сам файл .gitignore тоже будет игнорироваться.

Теперь Никитин локальный репозиторий отстает от того, что размещено на GitHub, на один коммит.

### Как заполучить свою локальную версию репозитория

Если и у Славы и у Никиты есть по личному локальному репозиторию одного и того де проекта, логично, что они откуда-то его "стянули".

Для того, чтобы работать с удалённым репозиторием, необходимо, для начала, его создать. На GitHub это делается элементарно -- нажатием на кнопку.

![Создание нового репозитория](/assets/posts/2020-05-07-github-1/newrepo1.jpg)

После заполнения таких полей, как "название" и "описание" мы попадаем на страницу репозитория на GitHub:

![Параметры нового репозитория](/assets/posts/2020-05-07-github-1/newrepo2.jpg)

![Новый репозиторий](/assets/posts/2020-05-07-github-1/newrepo3.jpg)

Собственно на странице нового репозитория все подробно описано :)
Если у тебя уже есть какие-то коммиты, которые ты хочешь запихнуть в новый репозиторий, используй
```bash
git remote add origin _адрес_твоего_репо_
git push -u origin master
```

Если же никакого кода ты еще не писал, и просто хочешь иметь собственную локальную копию существующего репозитория, используй
```bash
git clone _адрес_репо_
```
Эта команда создаст новую папку в текущем расположении, в которой будет находиться точная копия удалённого репозитория. В неё ты также можешь коммитить изменения и пушить их в удалённый репо (если у тебя есть к нему доступ на запись).

## Credits

В этот раз я рассмотрел самые простые и наивные приёмы работы с Git. Дальше будет горячее!

А вот, как была залита в интернеты страничка, на которой ты сейчас находишься:

![git status & git add](/assets/posts/2020-05-07-github-1/push1.jpg)
![git commit](/assets/posts/2020-05-07-github-1/push2.jpg)
![git push](/assets/posts/2020-05-07-github-1/push3.jpg)

*[ПО]: Программное обеспчение
