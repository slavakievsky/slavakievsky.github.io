---
layout: post
title: Изучение React.js Часть 1
description: Создание простого React.js проекта, устройство проекта, добавление элементов, декларативный и объектный подходы.
tags: [web, frontend, education, react.js]
---

В этой вводной части заметок про React.js мы разберем структуру проекта и добавим собственный элемент на страницу.
<!--more-->

## React.js
**React** -- это всего лишь библиотека JavaScript, которая позволяет программисту абстрагироваться от множества
моментов, связанных с написанием HTML+CSS+JS кода при создании пользовательского интерфейса веб-приложения.

В *React* используется *декларативный подход* к описанию интерфейса. Это значит, что программист должен лишь
*описать* желаемое состояние и поведение вместо того, чтобы "объяснять" машине, какие шаги нужно пройти
для достижения желаемого результата. Программист -- описывает результат, а всю работу по переводу этого описания
на императивный язык берет на себя React.

В этом, как и на мой взгляд во многом другом, код, используемый в React очень похож на простой HTML код.
В дальнейшем мы, надеюсь, не раз убедимся, что программировать UI на React очень приятно :3

### Для чего нужен React.js
*React* используется для создания пользовательских интерфейсов веб-приложений. Также есть возможность,
используя компонент *React Native*, разрабатывать приложения для мобильных устройств.

Замечательной особенностью React является постоянное динамическое обновление компонентов страницы, таким образом
обеспечивается постоянная синхронизация данных и видимого интерфейса. Ура! Нам больше не нужно каждый раз писать 
обработчики событий для каждого элемента, содержащие лапшу из операторов, изменяющих состояние сотни объектов!!!

### Как работает React.js
Так как в React используется собственный язык разработки/программирования/описания интерфейсов, можно сказать,
что React компилирует декларативный код в обычную HTML разметку, добавляя к ней соответствующие стили CSS и приправляя
вовремя и кстати подключенными JavaScript.

То есть тот самый код, который дивным образом избавляет нас от написания вереницы императивного кода, преобразуется
в самый обыкновенный JavaScript.

### Установка
*React* -- библиотека JavaScript. Поэтому в принципе для него приемлем любой способ установки библиотеки JS.

В моём случае React будет установлен, как пакет для Node.js при помощи инструмента npx.

Если ты (как и я) используешь какую-то IDE для разработки, то скорее всего всё, что тебе нужно сделать --
это нажать что-то типа "Create...React". Главное, не ошибиться с выбором между "React" и "React Native" =) Нам нужен простой React.

Если же ты (как, в прочем, и я) ярый приверженец консольного хардкора уровня dark souls, то установка базового окружения
для разработки React приложения будет выглядеть так (считаем, что у тебя уже есть Node.js и npm c npx):

```shell
npx create-react-app {your-app-name}
```

Примечательно, что в данной конфигурации создается _только_ фронтендовая часть, так что в теории ее вполне
удобно разрабатывать отдельно, а уже потом повесить, к примеру, на какой-то бэкенд.

Для тех, кто проходит данный квест на уровне "dark souls за нищего", существует [файл](https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html) для нулевой конфигурации.
В данном случае ничего устанавливать не надо -- просто программируй в отдельном файле. Будет работать. Медленно. Но будет.

### Обзор синтаксиса JSX и TSX
Итак, наше React приложение создано. Но перед тем, как запускать свои программистские лапки в код,
позволь, я немного расскажу про то, **с каким** монстром нам придется столкнуться.

Если ты просто установил React, то ты будешь программировать интерфейс на языке **JSX**.

Если ты (как и я) извращенец статической типизации и установил к тому же TypeScript, то твой монстр будет
называться **TSX**.

И *JSX*, и *TSX* суть декларативный язык программирования UI, используемый в React. Код JSX (TSX) выглядит,
как обычный JavaScript (TypeScript) код с тем лишь отличием, что мы будем использовать теги для встраивания объектов о.о

Сложно? Сейчас объясню. Смотри, предположим, что мы написали код какого-то объекта для интерфейса, например, какую-то форму.
Пусть соответствующий класс называется *Form1*. Теперь, чтобы вставить парочку экземпляров этого класса на
страницу, нам нужно поставить несколько вот таких тегов:

```html
<Form1 Param1={value1} Param2={value2} />
```

Разберем данный тег:
1. *Имя тега* соответствует названию нашего компонента
2. *Параметры* -- это специальные параметры, от которых может зависеть вид или поведение нашей формы. Код формы будет получать к ним доступ (на чтение), и мы сможем их использовать внутри формы.
3. *{value}* -- это специальный способ вставить JS код внутрь JSX разметки. В данном случае мы передаем значение переменной value1 в качестве первого параметра.

Собственно на данный момент это всё, что я могу рассказать про JSX синтаксис =)

Создаём свои классы для элементов интерфейса, используем из при помощи тегов, передаём параметры.

Остальную работу сделает сам React.

## Структура приложения React.js
Если ты не использовал метод с отдельным HTML файлом, то после создания React приложения у тебя появилась папка
с кучей папок и файлов:

![public](/assets/posts/2021-01-20-self-learning-frontend-2/public.jpg)

### Где хранятся страницы
Как мы знаем, страница, которую нам покажет браузер, должна быть написана на языке разметки HTML.

В только что созданном проекте будет только одна страница -- *index.html*. Она, как и всё, что по идее относится
к тому, что получает непосредственно браузер, расположена в папке **public**.

Если мы заглянем внутрь файла *index.html*, мы код, в котором более всего нас интересует данная часть:

```html
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
```

> Здесь и далее: если ты используешь JavaScript, то расширения файлов у тебя будут не **tsx**, а **js**

Файлу *index.html* соответствует файл *index.tsx*:

```tsx
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

В данном файле мы можем видеть императивный код, который вставляет в элемент HTML с **id** "*root*" (тот самый из index.html)
результат выполнения метода *ReactDom.render*.

Теперь мы точно знаем, что тут происходит, где находится наша страница, и что туда попадёт.

Как ты видишь, в метод *ReactDom.render* первым параметром передается строка из HTML тегов. Но выглядят они как-то необычно.
Это не простые теги, а то самое JSX.

Легко заметить, что внутри служебного тега *React.StrictMode* расположен тег *App*. Вот как раз там и находится код нашего приложения.

### Где хранится код интерфейса
Код, используемый для построения приложения, расположен в корне проекта в папке **src**.

> Здесь и далее: если ты используешь JavaScript, то расширения файлов у тебя будут не **tsx**, а **js**

Там ты найдешь, в том числе, и файл **App.tsx**. Заглянув в него, мы увидим, каким образом создаются компоненты интерфейса React:

```tsx
import React from 'react';
import logo from './logo.svg';
import './App.css';
import GreetingForm from "./Greeting/GreetingForm";

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.tsx</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;
```

Весь код условно можно разделить на три части:
1. *Импорты* -- обязательным является только *import React from "react"*. В остальном это работает так же, как и в нормальном JS коде.
2. *Код компонента* является сущностью JS. Как видно в примере выше, эта сущность -- функция, которая возвращает последовательность тегов, какую мы уже пару раз видели. Но такая сущность может быть и классом, о чём мы скажем чуть позже.
3. *Экспорт компонента* необходим для того, чтобы его можно было использовать в другом JSX коде.

В целом ты видишь, что внутри оператора *return* в функции находится такой же код, который был в методе *React.StrictMode*.
То есть мы легко можем создать собственный компонент и просто вставить его в файл при помощи тега.

## Создание приложения
Теперь, когда мы точно знаем, где что находится, настало время добавить на страницу несколько собственных элементов интерфейса.

Я буду делать строку ввода, под которой будет расположено приветствие.

### Добавление на страницу элементов
Чтобы добавить элемент на страницу, необходимо добиться выполнения всего двух условий:
1. Создать компонент интерфейса
2. Поставить тег с названием компонента в один из уже добавленных компонентов (то есть компоненты могут быть вложены друг в друга)

В нашем случае я хочу создать три компонента, подчинённых следующей иерархии:
* Форма приветствия (контейнер) *GreetingForm*
    * Строка ввода *Input*
    * Строка приветствия *GreetingHello*
    
Эта структура обозначает, что в код App я помещу только тег GreetingForm.

А уже внутри кода, отвечающего за GreetingForm, я помещу два тега: Input и GreetingHello, каждый из которых "встроит"
соответствующий код компонентов.

Перед тем, как создавать компоненты, предлагаю рассмотреть два возможных пути:
#### Функциональный подход
Этот подход мы уже видели, когда рассматривали *App.tsx*. При таком подходе сущностью, содержащей код разметки,
является обычная функция.

Такой код намного быстрее работает и намного проще тестируется. Вот простой пример: давай напишем код компонента, который содержит строку "Hello world!":
```tsx
function HelloWorld(){
    return(
        <p>Hello world!</p>
    );
}
```

Такой компонент будет использован следующим образом:

```tsx
<HelloWorld/>
```

Но что делать, если мы хотим передать параметры? Чтобы приветствовать не мир, а конкретного человека?

Делается это очень просто, при помощи передачи параметров. Передаются они так же, как и в случае с обыкновенными
тегами, а внутри компонента доступны через объект **props**. Также воспользуемся стрелочными функциями, и напишем код для компонента:

> Если вы используете JavaScript, а не TypeScript, исключите из кода аннотации типов.

```tsx
const HelloWorld = (props: any) => (
    <p>Hello {props.Name}!</p>
);
```

Использовать такой компонент следует таким образом:
```tsx
<HelloWorld Name={name}/>
```

Где переменная **name** принимает какие-то значения по ходу исполнения кода.

#### Объектный подход
В случае использования данного подхода мы получаем все возможности ООП в JS, теряя только в скорости.

Тот же самый пример с приветствием человека будет выглядеть следующим образом:

```tsx
class GreetingForm extends React.Component<any, any> {
    render(){
        return(
            <p>Hello {props.Name}!</p>
        );
    }
};
```

Здесь следует обратить внимание на несколько моментов:
1. Если мы создаем компонент интерфейса, как класс, то этот класс должен наследовать класс *React.Component*
2. В отличие от функций, здесь нам необходимо явно определить метод *render()*, внутри которого в конструкции *return()* и происходит вся магия JSX

### Состояние компонента

Компоненты могут содержать некоторые данные. Набор таких данных есть *состояние*. Грубо говоря, это замена полям класса для JSX.

Например у меня есть поле ввода *input* и я хочу, чтобы в зависимости от введенного значения менялось поведение компонента.

Такой компонент следует описывать таким образом:

```tsx
class Input extends React.Component<any, any>{
    state = {
        value: ""
    }

    render(){
        const {className, Id, Name} = this.props;
        const {value} = this.state;

        return(
            <input type="text" className={className} id={Id} name={Name}/>
        );
    }
};
```

Обрати внимание, как я объявляю поле **state**. Это и есть состояние компонента.

Внутри метода **render** ты можешь заметить, что я использую конструкции вида **const {value, err} = this.state**.
Это деструктуризация объекта -- стандартная возможность JS.

Доступ к состоянию мы получаем через **this.state**, доступ к параметрам, с которыми компонент использован в разметке, получаем через **this.props**.

Данный компонент будет использован следующим образом:

```tsx
<Input className="myclassname" Id={id_var} Name={name_var}/>
```

### Обработка событий
Легко заметить, что мы хотя и добавили в наш компонент состояние, мы никаким образом его не используем.
Более того, значение этого параметра состояние (value) даже не обновляется, как бы нам того хотелось.

Чтобы реализовать данный механизм, воспользуемся возможностями JSX по обработке событий:
1. Создадим внутри компонента функцию-обработчик
2. Добавим в тег *input* этот обработчик

Получится следующий код:

```tsx
class Input extends React.Component<any, any>{
    state = {
        value: "Friend",
    }

    onChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        this.setState({
            value: event.target.value
        });
    };


    render(){
        const {className, Id, Name} = this.props;
        const {value} = this.state;

        return(
            <input type="text" onChange={this.onChange} className={className} id={Id} name={Name}/>
        );
    }
};
```

Теперь при каждом изменении значения в поле ввода будет вызван метод **onChange**.

Обрати внимание, каким образом я произвожу изменение значения внутри состояния: я не присваиваю значение,
а использую специальный метод *this.setState()*, внутри которого уже указываю, какое поле должно принять какое значение.
Во-первых, это декларативный подход. Во-вторых, это необходимо для правильной работы React.

## Создание приложения
Теперь вернемся к нашему приложению. Напомню, оно будет иметь следующую структуру:
* Форма приветствия (контейнер) *GreetingForm*
    * Строка ввода *Input*
    * Строка приветствия *GreetingHello*
  
Всё это будет помещено внутрь компонента *App*.

Начну с самого простого: строки приветствия. По аналогии с рассмотренным примером, напишем её в функциональном стиле:
```tsx
import React from "react";

const Hello = (props: any) => (
    <p className={props.className}>{props.Name}</p>
);

export default Hello;
```

Я специально добавляю такие параметры, как className и Name в свойства компонента, чтобы при необходимости было
проще стилизовать наши художества.

Теперь добавлю компонент для ввода имени:

```tsx
import React from "react";

class Input extends React.Component<any, any>{
    state = {
        value: "Friend",
        err: "",
    }

    onChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const {onChange} = this.props;

        onChange && onChange(event);

        this.setState({
            value: event.target.value
        });
    };


    render(){
        const {className, Id, Name} = this.props;
        const {value, err} = this.state;

        return(
            <input type="text" onChange={this.onChange} className={className} id={Id} name={Name}/>
        );
    }
};

export default Input;
```

Подобный пример также был рассмотрен ранее, но здесь мне было необходимо добавить к параметрам компонента
также обработчики событий, которые будут вызваны в процессе внутренней обработки.

Ну и наконец компонент, который объединит Input и Hello:

```tsx
import React from "react";
import Input from "./Input";
import Hello from "./GreetingHello";

class GreetingForm extends React.Component<any, any>{
    state = {
        currentName: ""
    }

    inputValueChanged = (event: React.ChangeEvent<HTMLInputElement>) => {
        this.setState({
            currentName: event.target.value
        });
    }

    render(){
        const {className} = this.props;
        const {currentName} = this.state;

        return(
            <div className={className}>
                <Input className={`${className}__input`} onChange={this.inputValueChanged}/>
                <Hello Name={currentName} className={`${className}__hello`}/>
            </div>
        );
    }
};

export default GreetingForm;
```

Теперь наглядно видно, для чего я добавлял внутрь Input собственный параметр onChange.

Таким образом при изменении значения в поле ввода будет не только выполняться внутренний обработчик, выставляющий
значение состояния value в введенное значение, но и обработчик, добавленный внутри GreetingForm, который
изменит состояние currentName. Этот параметр необходим чтобы вывести приветствие с помощью Hello.

Ну и наконец, чтобы всё заработало, необходимо использовать компонент GreetingForm внутри компонента App(Я вставлю его в header):

```tsx
<header className="App-header">
        <GreetingForm className="greeting"/>
        <img src={logo} className="App-logo" alt="logo" />
        <p>
```

Давай посмотрим, что получилось:

![](/assets/posts/2021-01-20-self-learning-frontend-2/demo.gif)

А вот такую разметку в итоге сгенерировал нам React из компонента GreetingForm:

```html
  <div class="greeting">
    <input type="text" class="greeting__input">
    <p class="greeting__hello"></p>
  </div>
```

При просмотре разметки в инструментах разработки видно, что на input повешен обработчик событий. Правда уже не JSX-овый, а обчыный,
джаваскриптовский.

А вот такая структура проекта у меня получилась:

![final](/assets/posts/2021-01-20-self-learning-frontend-2/final.jpg)

Я поместил все, что связано с формой приветствия, в отдельный подкаталог и, конечно же, каждый компонент разместил в отдельный файл.