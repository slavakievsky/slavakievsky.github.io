---
layout: post
title: Изучение React.js Часть 2. Крестики-нолики
description: Первые шаги в разработке на React.
tags: [web, frontend, education, react.js]
---

В этот раз я решил применить некоторые из рассмотренных в первой части концепций и приемов на практике. Задача не этот раз -- написать игру "крестики-нолики".

<!--more-->

## Попробуем декомпозировать задачу
Передо мной стояла задача: "сделать игру крестики-нолики на React". При этом
код игры должен был быть максимально простым и модульным.

Из чего состоит игра?
1. Из доски, на которой располагаются...
2. ...клетки, в которых могут быть крестики, нолики или ничего
3. Из ходов двух игроков, у каждого из которых собственный знак.

Каковы правила игры?
* Можно поставить только свой символ
* Символ можно ставить только в свободную клетку
* За один ход игрок может поставить только один символ = как только символ установлен, ход автоматически
переходит ко второму игроку
  
Исходя из вышеперечисленных свойств игры я решил, что для решения поставленной задачи
хорошо подойдёт следующий план реализации:
1. Крестики-нолики
    1. Интерфейс
       1. Доска
          * Данные о состоянии партии
          * Клетки доски
       2. Кнопка сброса
    2. События
       1. Клик по клетке доски
       2. Клик по кнопке сброса

## Необходимые компоненты
После того, как появился план реализаци, хорошо видно, из каких компонентов
должно состоять приложение. Сразу оговорюсь: в этот раз я не буду использовать контексты и Redux в виду
простоты приложения.

Прежде, чем я приведу своё решение относительно системы компонентов, стоит сказать
пару слов о том, в каких случаях я считаю целесообразным использование классов, а в каких -- функций.

### Классы или функции?
В React при создании компонентов традиционно доступно две опции:
1. Реализация класса наследника *React.Component*, реализующего метод render(), возвращающий элемент JSX
2. Реализация функции, возвращающей элемент JSX (ReactNode)

До версии React 16 было принято считать, что классы используются, если внутри компонента есть какие-то данные,
а функции -- если компонент служит лишь для отображения некоторых данных (то есть не содержит собственные данные).

Такие "данные", кстати, называются *state*.

Однако с приходом Хука **useState** для функциональных компонентов React также стало возможно
сохранения состояния. То есть можно сохранить какие-то значения между вызовами функции:

```tsx
import {useState} from "react";

export default function Comp(){
    [counter, setCounter] = useState(-1);
    
    setCounter(++counter);
    
    return(
        <div>{counter}</div>
    );
}
```

Такой код будет порождать простой div блок, однако при каждом вызове функции (при каждой отрисовке компонента)
значение внутри дива будет увеличиваться на единицу.

Синтаксический сахар довольно прост и расшифровывается следующим образом:

```tsx
[{переменная}, {функция_для_обновления_значения}] = useState({значение_по_умолчанию});
```

Интересный момент: порождающая функция называется не "createState", а именно "useState",
так как при повторном вызову функции значения должны именно использоваться, а не создаваться
заново.

Итак. Что же использовать теперь, в эпоху useState? Свой выбор сегодня и, вероятно, в дальнейшем я 
обосновываю следующим образом:

**Класс** реализуется, если компонент является идеологическим хозяйствующим владельцем данных, которые в нём содержатся
и параметрически напрямую не зависит от родителя.

**Функция** реализуется, если компонент использует данные родительского класса.

То есть, на примере крестиков-ноликов:

*доска* -- **класс**, так как является независимым владельцем данных о состоянии игры (где какие символы стоят)
и единоличным "управленцем" этими данными, что исключает возможность обхода правил игры.

*клетка доски* -- **функция**, так как служит только для отображения части данных о состоянии игры
и передачи события клика доске (компонент не может самостоятельно повлиять на состояние игры, а лишь запрашивает у неё изменение, что я считаю маст-хэв свойством любой игры).

*кнопка сброса* -- **функция**, так как является компонентом игры и не содержит собственных данных: служит
лишь для передачи доске сообщения о клике.

НО!) В целях практики использования useState я буду реализовывать доску, как функцию)

### Иерархия компонентов React
Разобравшись с функциями и классами, я решил разделить объекты, следую принципу единственной ответственности
и модульности кода с возможностью повторного использования компонентов, следующим образом:

![Src](/assets/posts/2021-01-25-self-learning-frontend-3/structure.jpg)

Файлы ".sass"-- это стили для соответствующих элементов, написанные на SASS.

## Детали и тонкости реализации

### Данные об игре
Так уж получилось, что данные о состоянии партии в крестики-нолики находятся у компонента "Board",
в то время, как фактически отображением состояния являются компоненты "Cell".

Чтобы избежать копирования данных в памяти и не допускать возможность изменения состояний клетками,
все данные об игре будут помещены в компонент Board, а каждому элементу необходимые данные будут
передаваться параметрически (JSX обеспечивает защиту от изменения при таком способе передачи
сверху вниз)

Данные об игре состоят из двух параметров: состояние доски и текущий ход.
Вот реализация в компоненте Board этих параметров:

```tsx
const default_cells = Array(rowCount).fill(null).map((_, i) => (
    {row_id: i, row: Array(columnCount).fill(null).map((__, c) => (
            {cell_id: c, cell_state: cellState.Null}
        ))
    }
));
const default_turn = cellState.X;

const [cells, setCells] = useState(default_cells);
const [turn, setTurn] = useState(default_turn);
```

Для того, чтобы не пересоздавать/обходить массив каждый раз при сбросе состояния игры,
я решил инициализировать значение по-умлочанию.

Хотя массив и является ссылочным типом данных, функция useState, тем не менее, выполняет копирование.

Обрати внимание: я создаю не просто массив состояний клеток, а массив объектов-строк, заполненных клетками доски:
* Строка:
    * row_id: number -- идентификатор строки
    * row: []: -- строка, состоящая из объектовЖ
        * Клетка:
            * cell_id: number -- идентификатор конкретной клетки в строке
            * cell_sate: string -- состояние строки (вариант из cellState)

О необходимости идентификаторов я расскажу чуть позже, когда дойдём до клеток на доске.

### Кнопка
Кнопка -- самый простой компонент React, так что список компоненов начать я решил именно с него.

По сути данный компонент просто JSX обертка над HTML тегом Button. По большей части
я реализовал его, как отдельный компонент, из тяги к обобщению (а вдруг я захочу в эту кнопку
что-то более сложное добавить? Оверинжиниринг? Да!!).

Плюс такой метод позволит мне попробовать два способа "пробрасывания" событий через компоненты)

Приведу полный листинг компонента Button:

```tsx
import React from "react";
import { useState } from "react";

import "./Button.sass";

export default function Button({displayText, onClick}: {displayText: string, onClick?: any}){
    const onButtonClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        onClick && onClick();
    }

    return(
        <button className="Button" onClick={onButtonClick}>{displayText}</button>
    );
}
```

useState тут не нужен, но я его включил просто, чтобы показать, как его импортировать.

Рассмотрим некоторые нюансы данной реализации:

#### Входные параметры функции

Я пишу на TypeScript JSX, поэтому мне необходимо использовать типы при объявлении функции.

В данном случае я указал тип  деструктурируемого в параметрах объекта прямо внутри функции, однако
существует более "правильный" способ с интерфейсом, который я, тем не менее решил опустить, чтобы
не добавлять лишний export и соответствующий ему import:

```tsx
import React from "react";
import { useState } from "react";

import "./Button.sass";

export interface ButtonProps{
    displayText: string,
    onClick?: any,
}

export default function Button({displayText, onClick}: ButtonProps){
    const onButtonClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        onClick && onClick();
    }

    return(
        <button className="Button" onClick={onButtonClick}>{displayText}</button>
    );
}
```

#### Событие по клику на кнопку
Наша кнопка, как увидишь далее, будет использоваться таким оразом:

```tsx
<Button displayText="Refresh" onClick={onRefreshButtonClick}/>
```
То есть функция по клику, что справедливо, будет находиться у родительского элемента,
а наш компонент должен будет вызвать её по переданной ссылке (в JS типы данных ссылочные).

Добиться такого эффекта можно двумя путями:
1. Определить внутри компонента функцию, внутри которой вызвать преданную параметром функцию
2. Определить интерфейс, который наследует интерфейс соответствующего компонента (в нашем случае button)
и передать активному тего (button) все наследуемые параметры
   
Первый способ хорош, если компонент хочет немного изменить передаваемые в событие параметры или что-то ещё сделать кроме того,
о чем его попросил родитель.

Второй способ хорош, если реализуемый JSX компонент полностью функционально реализует
поведение какого-то другого компонента.

Выше в листинге видна реализация первого способа. Думаю, что второй покажу в следующих частях.

### Доска
Начнем с доски.

За основу отображающего блока я решил взять обыкновенную HTML таблицу, поместив ее в отдельный div блок.
Структура разметки доски на мой взгляд крайне проста:
* div.Board
    * table.Board__table
        * tbody
            * ...
    * Button (JSX компонент)
    
Внутри tbody будет расположено N строк, по M ячеек в каждой. В каждую ячейку я помещу клетку (об этом ниже).

#### События
Прежде чем пойти дальше я решил подготовить необходимые функции, реагирующие на события.

Как мы помним, в игре есть следующие типы событий:
* Клик по клетке доски
* Клик по кнопке сброса

При клике по клетке должна пройти проверка на занятость доски, а также передача ходу другому игроку:

```tsx
const onCellClick = (row: number, cell: number) => {
        if (cells[row].row[cell].cell_state === cellState.Null){
            const newcells = cells.slice();
            newcells[row].row[cell].cell_state = turn;

            setCells(newcells);
            setTurn((turn === cellState.X) ? cellState.O : cellState.X);
        }
    }
```

В данном случае я решил не заморачиваться с индексами, так как точно знаю, что в процессе
игры клетки расположены на доске консистентно и не перемещаются.

Что касается сброса игры, я снова решил (в угоду модельности) реализовать отдельную функцию
для сброса партии, а затем уже обработчик события, её использующий:

```tsx
const refreshCells = () => {
        setCells(default_cells);
    }

const onRefreshButtonClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    refreshCells();
    setTurn(default_turn);
}
```

Вот так будет выглядеть компонент Board, реализующий данный функционал:

```tsx
export default function Board({rowCount, columnCount}: {rowCount: number, columnCount: number}){
    const default_cells = Array(rowCount).fill(null).map((_, i) => (
        {row_id: i, row: Array(columnCount).fill(null).map((__, c) => (
                {cell_id: c, cell_state: cellState.Null}
            ))
        }
    ));
    const default_turn = cellState.X;

    const [cells, setCells] = useState(default_cells);
    const [turn, setTurn] = useState(default_turn);

    const refreshCells = () => {
        setCells(default_cells);
    }

    const onCellClick = (row: number, cell: number) => {
        if (cells[row].row[cell].cell_state === cellState.Null){
            const newcells = cells.slice();
            newcells[row].row[cell].cell_state = turn;

            setCells(newcells);
            setTurn((turn === cellState.X) ? cellState.O : cellState.X);
        }
    }

    const onRefreshButtonClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        refreshCells();
        setTurn(default_turn);
    }

    return(
        <div className="Board">
            <table className="Board__table">
                <tbody>
                {/* Тут будут клетки */}
                </tbody>
            </table>
            <Button displayText="Refresh" onClick={onRefreshButtonClick}/>
        </div>
    );
}
```

### Клетка доски

#### Состояние клетки
Состоянием я решил назвать крестик, нолик или пустую клетку.
Чтобы сделать код более обобщённым и "оторвать" детали о состоянии клетки от логики игры,
я решил поместить варианты состояния в спциальный объект cellState:
* Null => ""
* X => "X"
* O => "O"

Это позволит мне при необходимости использовать любые выражения для разных состояний клетки,
изменяя при этом только одно выражение непосредственно внутри cellState.

#### Реализация клетки
Клетка доски -- это простой див, внутри которого я помещу span для отображения
состояния клетки:

```tsx
import React from "react";

import "./Cell.sass";

export default function Cell({cellState}: {cellState: any}){
    return(
        <div className="Cell">
            <span className="Cell__state">{cellState}</span>
        </div>
    );
}
```

Клик по клетке я решил обрабатывать прямо внутри доски Board.

### Репликация клеток доски
Я решил, что размер игры может быть любым: 3х3, 10х3...
По этой причине ну никак не получится руками прописать девять экземпляров Cell внутри Board.
Естественным образом напрашивается использование цикла, однако JSX -- декларативный язык программирования,
поэтому необходимо создать массив клеток доски и с помощью метода map() превратить его в набор компонентов интерфейса:

Как ты помнишь, состояние партии есть массив объектов-строк, заполненных клетками доски:
* Строка:
    * row_id: number -- идентификатор строки
    * row: []: -- строка, состоящая из объектовЖ
        * Клетка:
            * cell_id: number -- идентификатор конкретной клетки в строке
            * cell_sate: string -- состояние строки (вариант из cellState)
    
Для чего нужны идентификаторы строк и клеток в них? Дело в том, что далее,
в коде, который описывает разметку непосредственно доски, я использовал метод map(),
а для правильного обновления DOM элементов React требует, чтобы каждый компонент разметки
имел уникальное значениа параметра *key*:

> Неправильно! React не сможет правильно отрисовывать строки и клетки в них!

```tsx
<div className="Board">
    <table className="Board__table">
        <tbody>
            {cells.map((row, _) => (
                <tr>
                    {row.row.map((cell, __) => (
                        <td>
                            <Cell cellState={cell.cell_state} onClick={() => onCellClick(row.row_id, cell.cell_id)}/>
                        </td>
                    ))}
                </tr>
            ))}
        </tbody>
    </table>
    <Button displayText="Refresh" onClick={onRefreshButtonClick}/>
</div>
```

> Верный вариант разметки:

```tsx
<div className="Board">
    <table className="Board__table">
        <tbody>
            {cells.map((row, _) => (
                <tr key={`row-${row.row_id}`}>
                    {row.row.map((cell, __) => (
                        <td key={`cell-${cell.cell_id}`} onClick={() => onCellClick(row.row_id, cell.cell_id)}>
                            <Cell cellState={cell.cell_state}/>
                        </td>
                    ))}
                </tr>
            ))}
        </tbody>
    </table>
    <Button displayText="Refresh" onClick={onRefreshButtonClick}/>
</div>
```

При таком способе разметки каждый дочерний элемент внутри каждого родителя имеет уникальное значение *key*

Может показаться, что хорошей альтернативой было бы использование второго параметра функции внутри
метода map() -- индекса в массиве. **Но это не верно!** Дело в том, что если в твоём приложении
будет меняться состав массива (добавление иди удаление элементов), один и тот же компонент может получать
разные значение параметра *key*. Поэтому хорошей (и, на мой взгляд, единственно верной) практикой
в таких случаях является использование *id*, хранящегося внутри самого объекта.

## Ну и наконец...

Исходники лежат [тут](https://github.com/pushsla/try.react.js/tree/XO).

Gif-демка:

![Demo](/assets/posts/2021-01-25-self-learning-frontend-3/demo.gif)