---
layout: post
title: Первые шаги в Rust. Стек
description: Первые шаги в разработке на Rust
tags: [education, rust]
---

Сегодня мы попробуем реализовать структуру "стек" на языке Rust и применим её для решения классической задачи
по определению правильности скобочной последовательности.

<!--more-->

## Создание проекта и его структура
Для начала нам необходимо создать проект Rust. Управлением проектами занимается пакетный менеджер **cargo**.
С его помощью можно собирать проекты, подтягивать зависимости и много чего еще.

Создается проект достаточно просто:

```bash
cargo new rust-vector
```

создаст каталог *rust-vector* со следующим содержимым:

```shell
rust-vector
├── Cargo.toml
└── src
    └── main.rs
```

В файле *Cargo.toml* мы будем настраивать нашу программу: подтягивать зависимости, управлять метаданными.
Но сегодня это нам не нужно, так что перейдем сразу к папке *src*, в которой лежит исходники.

В файле *main.rs* находится точка входа для программы, представляющая собой следующую функцию:

```rust
fn main() {
    println!("Hello, world!");
}

```

Именно в нём мы и начнем разработку программы.

## Как нам сделать вектор? ООП?
Перед тем, как решать задачу, нужно разработать что-то, что будет работать, как вектор:
* LIFO очередь
* Опарации push и pop
* Операция top
* Вспомогательные операции: clear, size, capacity, is_empty

Что напрашивается на роль паттерна реализации? Класс ООП. Но как обстоит дело с этим в Rust?

В Rust ООП присутствует в несколько неявном виде. На мой взгляд это как бы не ООП, но
в то же время программист может воспринимать это, как ООП.

Методы, строго говоря, -- не методы и вообще отделены от структуры объекта. Интерфейсов нет: вместо них
типажи. Данные отделены от реализации поведения.

Короче говоря, в Rust наш "класс" строится из нескольких независимых кирпичиков, которые, работая вместе,
и предоставляют нам возможности ООП.

### Первый кирпичик -- Struct
Первый кусок любого объекта -- это инкапсулированные данные. Иными словами структура данных.

В Rust структура данных является фундаментом класса и определяет поля и их типы. Опишем
структуру Stack, пока предположив, что в стеке будут лежать целые числа.

```rust
struct Stack{
    stack: Vec<i64>
    capacity: usize,
}
```

В смысле данных стек представляет собой структуру ограниченного размера. Поэтому, несмотря на то, что
Vector в Rust безразмерен и в данном случае ограничение на кол-во элементов в стеке будет искусственным,
я его реализую, чтобы попробовать пару интересных механизмов Rust.

Итак, мы описали данные класса. Настало время заняться его поведением.

### Impl
Первое, что приходит в голову, когда мы начинаем говорить о методах/поведении класса -- конструктор.

В Rust конструктор является независимой функцией, возвращающей новую структуру. Не существует синтаксического
понятия "конструктор", поэтому решение о его реализации/не реализации и именовании программист принимает сам.

Я, следуя принятому соглашению, реализую конструктор с именем *new*.

Для того, чтобы определить связанное со структурой поведение (методы), используется директива **impl**.

**struct** было как бы "объявлением типа", а это будет как бы "реализация".

```rust
impl Stack{
    fn new(capacity: usize) -> Stack{
        Stack{
            stack: Vec::with_capacity(capacity),
            capacity
        }
    }
}
```

Здесь видно, что, к примеру, у Vec используется метод **with_capacity**, который работает, как конструктор.
Но у Vec есть еще несколько функций, которые возвращают экземпляр Vec. Поэтому у структуры может быть несколько
разных конструкторов.

Сама функция **Stack::new()** и будет в нашем случае конструктором класса.

Теперь реализуем остальные методы:

```rust
impl Stack{
    fn new(capacity: usize) -> Stack{
        Stack{
            stack: Vec::with_capacity(capacity),
            capacity
        }
    }
    fn push(&mut self, value: i64){
        self.stack.push(value);
    }
    fn pop(&mut self) -> i64{
        self.stack.pop().unwrap()
    }
    fn top(&self) -> i64{
        self.stack.last()
    }
    fn is_empty(&self) -> bool{
        self.stack.len()
    }
}
```

Здесь есть сразу несколько достойных внимания вещей:

**&mut self** и **&self** -- это ссылки на структуру. Функции, принимающие первым такой аргумент
и будут вести себя, как методы. Важно отметить, что, если внутри метода мы собираемся изменять состояние
структуры, необходимо требовать передачи мутабельной ссылки.

**Возвращаемые значения** не требуется отдельно выделять блоком типа return. Rust ориентирован на
выражения, а потому последнее вычисленное выражение и будет возвращаемым значением. Если после выражения стоит
точка с запятой, значение не будет возаращено.

**unwrap()** необходим, так как метод стандартного Vector в Rust возвращает не элемент, а enum Option<T>.
Вот, как он выглядит:
```rust
enum Option<T>{
    Some(T),
    None,
}
```
Он нужен именно для того, чтобы, если внутри вектора ничего нет, функция pop могла вернуть значение ожидаемого
типа, не спровоцировав ошибку в программе. Метод *unwrap* позволяет получить значение типа T, содержащееся
внутри Option<T>

> Очень важно! Дочитай статью до конца, прежде чем пускать такой код в продакшн XD

### Generic
Настало время подумать. Подумать о том, что в стеке неплохо бы хранить переменные разных типов.
Речь не о динамической типизации, а о том, чтобы однажды реализовав Stack использовать его для разных типов.

Речь об "обобщённых типах" или о "generic'ах".

С такой штукой мы только что встретились: *Option<T>* и есть пример дженерика. Мы не знаем на этапе разработки,
какой тип будет хранить внутри себя Option, а потому указываем, что данный enum является не одним типом,
а целым множеством типов: Option<u32>, Option<&char>, Option<f64>, Option<Vec<Option<&str>>> и т.д.

Подставьте любой тип вместо T и получите новый тип Option<T>.

Теперь сделаем то же самое с нашим стеком:

```rust
struct Stack<T: Sized>{
    stack: Vec<T>
    capacity: usize,
}
```

Что такое <T: Sized>? Вкратце -- это требования к типу T. Таким образом я ограничил множество возможных
типов T теми, размер которых известен. Это необходимо для корректной работы вектора.

Теперь, так как наш стек стал типом с параметром T, изменению подлежат и реализации:
```rust
impl<T: Sized> Stack<T>{
    fn new(capacity: usize) -> Stack{
        Stack{
            stack: Vec::with_capacity(capacity),
            capacity
        }
    }
    fn push(&mut self, value: T){
        self.stack.push(value);
    }
    fn pop(&mut self) -> T{
        self.stack.pop().unwrap()
    }
    fn top(&self) -> &T{
        self.stack.last()
    }
    fn is_empty(&self) -> bool{
        self.stack.len()
    }
}
```

Готово. Обрати внимание: теперь наша реализация  на самом деле описывает множество реализаций
для каждого допустимого типа T.

Еще один момент: в методе top() возвращаемый тип не просто T, а **&T**. Это говорит о том, что
владение значением на вершине стека не переходит к родительскому коду, вызывающему метод top(), а остается
внутри вектора-стека. Мы как бы даём пользователю метода "подсмотреть", что внутри стека. То есть даём
значение "взаймы", так как оно все еще нужно стеку.

А вот в методе pop() возвращаемый тип есть **T**, так как переменная более не нужна стеку и право владения
ей переходит коду-пользователю метода.

## Что-то не так...
А именно, наш код содержит огромное множество проблем:
1. Я обещал, что размер стека будет ограничен, но этого не происходит
2. Программа вылетит, если стек будет пуст при вызове pop() или top()


В данном случае мы имеем дело с условиями, при которых результат (вылетит/не вылетит) зависит от программиста.
Значит надо не только предохранить наш стек от ошибок, но и дать пользователю класса обратную связь.
Для этого воспользуемся такой штукой, как Result.

Result -- это продвинутая версия Option в Rust:
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Основное отличие для нас состоит (кроме другого набора методов) в том, что теперь мы
можем не только передать/не передать значение, но и сообщить о причине отсутствия значения.

В данном случае **Ok** будет содержать возвращаемое значение в случае успеха, а **Err** будет
содержать данные об ошибке.

Поправим наши методы:
```rust
impl<T: Sized> Stack<T>{
    fn new(capacity: usize) -> Stack{
        Stack{
            stack: Vec::with_capacity(capacity),
            capacity
        }
    }
    fn push(&mut self, value: T) -> Result<(), &str>{
        if self.stack.len() < self.capacity{
            self.stack.push(value);
            Ok()
        }else{
            Err("Stack is full")
        }
    }
    fn pop(&mut self) -> Result<T, &str>{
        let popped = self.stack.pop();
        if popped.is_some(){
            popped.unwrap()
        }else{
            Err("stack is empty)
        }
    }
    fn top(&self) -> Result<&T, &str>{
        let last = self.stack.last();
        if last.is_some(){
            last.unwrap()
        }else{
            Err("stack is empty)
        }
    }
    fn is_empty(&self) -> bool{
        self.stack.len()
    }
}
```

Метод **is_some** является частью Option, и сообщает, есть ли там что-то или же это просто Option::None.

Готово. Теперь наш стек не крашнется и в любом случае вернёт пользователю класса результат операций. А
дальнейшее распоряжение этим результатом останется на совести пользователя класса =)

### if let
Все хорошо, кроме одного. Кода стало как-то многовато. Неужели в методах **pop** и **top** действительно
не обойтись без строки с присваиванием?

Оказывается, можно обойтись и без нее:

```rust
fn top(&self) -> Result<&T, &str>{
    if let Some(last) = self.stack.last(){
        last.unwrap()
     }else{
        Err("stack is empty)
    }
}
fn pop(&mut self) -> Result<T, &str>{
    if let Some(popped) = self.stack.pop(){
        popped.unwrap()
     }else{
        Err("stack is empty)
    }
}
```

Помнишь, что все в Rust есть выражение? Так вот "let a = b" -- это тоже выражение.

В данном случае проивзодится попытка деструктуризации объекта *self.stack.last()*, как
Option::Some с именем значения "last".

При успешной деструктуризации (Если внутри Option находится что-то), выполняется блок кода под if. В
противном случае (если self.stack.last() вернет Option::None), выполнится блок под else.

## Решение задачи
Алгоритм решения задачи достаточно прост:
1. Берем по одному символу из последовательности
2. Если он открывающий -- помещаем  стек
3. Если закрывающий, смотрим:
    1. Соответствует ли он по типу скобки тому, что лежит на вершине стека?
    * Если да, удаляем из стека верхнюю скобку -- эта последовательность закрыта корректно
    * Если нет, последовательность не верна.
4. Если после всех операций стек пуст и ранее мы не нашли ошабок -- последовательность верна.

Ну и, применив все навыки, получаем следующий алгоритм:

```rust
fn main(){
    let opens = "([{";
    let closes = ")]}";

    // Тип Stack<:?> сам определится компилятором на основе первой операции push()
    let mut stack = Stack::new(100);
    let string = "{()}()";
    let mut valid = true;

    for c in string.chars(){
        if valid {
            if opens.contains(c) {
                // Вот тут компилятор поймёт, что стек имеет тип Stack<char>
                if let Err(err) = stack.push(c){
                    println!("{}", err);
                    valid = false;
                }
            }else if closes.contains(c){
                if let Ok(topchar) = stack.top(){
                    // Мы точно уверены, что выполнение unwrap не приведет к panic,
                    // так как ранее происходила проверка if top.is_err()
                    // Можно было добавить проверку для closes.find(c), но предположим,
                    // что данные в let string введены корректно в учебных целях.
                    if opens.find(*topchar).unwrap() == closes.find(c).unwrap(){
                        if stack.pop().is_err(){
                            valid = false;
                        }
                    }else{
                        valid = false;
                    }
                }else{
                    valid = false;
                }
            }
        }
    }
    valid = valid && stack.is_empty();

    println!("{}", valid);
}
```

## На сладкое
### Модульный код
Давай вынесем наш стек в отдельный модуль?
Для этого создадим отдельный файлик **my_structs.rs**, в который поместим следующий код:
```rust
pub mod stack{
    pub struct Stack<T: Sized>{...}
    impl<T: Sized> Stack<T>{
        pub fn new(capacity: usize) -> Stack<T>{...}
        ...
        pub fn top(&self) -> Result<&T, &str>{...}
    }
}
```

Троеточие обозначает весь код, который мы писали до этого.

То есть мы перенесли стек из основного файла в отдельный модуль. Остальсь только его подключить внутри main:
```rust
mod my_structs;
```

... и правильно указать путь к структуре Stack:
```rust
let mut stack = my_structs::stack::Stack::new(100);
```

### Второй конструктор
Я тут решил: я давай сделаем еще один конструктор для нашего стека? Чтобы можно было сделать стек безразмерным.

```rust
impl<T: Sized> Stack<T>{
...

   pub fn new_sizeless() -> Stack{
        Stack{
            stack: Vec::with_capacity(capacity),
            capacity: usize::MAX,
        }
    }
```

Вот такие вот дела) Теперь у нас есть два конструктора)